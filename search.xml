<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深度学习与TensorFlow 2入门实战（一）基础部分</title>
    <url>/2019/10/21/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8ETensorFlow%202%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h2 id="深度学习初见"><a href="#深度学习初见" class="headerlink" title="深度学习初见"></a>深度学习初见</h2><p>以深度学习的算法讲解为主，以 TensorFlow 实践为辅，通过理论和实践的方法确保能理解算法。</p>
<h3 id="TensorFlow-简介"><a href="#TensorFlow-简介" class="headerlink" title="TensorFlow 简介"></a>TensorFlow 简介</h3><ul>
<li>2015.9 发布 0.1版本</li>
<li>2017.2 发布 1.0版本</li>
<li>2019春发布2.0版本</li>
</ul>
<h3 id="TensorFlow-vs-PyTorch"><a href="#TensorFlow-vs-PyTorch" class="headerlink" title="TensorFlow vs PyTorch"></a>TensorFlow vs PyTorch</h3><p>计算图 等概念使得用户使用起来困扰。</p>
<h3 id="TensorFlow-2-0"><a href="#TensorFlow-2-0" class="headerlink" title="TensorFlow 2.0"></a>TensorFlow 2.0</h3><p>Easy to use.</p>
<p>去掉图 等概念，这些概念使得 tf1 使用起来非常麻烦</p>
<ul>
<li>session.run | 去掉session概念</li>
<li>tf.control_dependencies | 去掉实施控制</li>
<li>tf.global_variables_initializer | 之前。变量命名体系 分 Python的和 其内部的</li>
<li>tf.cond, tf.while_loop | 去掉分支控制，这些可以用 python的 if..else完成，但是1.x 硬生生造了这样的概念</li>
</ul>
<p>变的 像 pytorch一样 所见即所得，比如</p>
<blockquote>
<p>tensorflow 在 各种排行都 比 pytorch 高</p>
</blockquote>
<h3 id="忘掉1-0"><a href="#忘掉1-0" class="headerlink" title="忘掉1.0"></a>忘掉1.0</h3><ul>
<li>计算图 Graph</li>
<li>会话 Session</li>
<li>变量管理 Variable 与 共享 reuse</li>
<li>define-and-run</li>
<li>等等一系列烦人的概念将一去不复返</li>
</ul>
<ul>
<li><p>我们假设你对 TensorFlow 一无所知</p>
<p>1.0 的概念在 2.0中用不到，2.0是自我革新，用户使用起来会丝滑顺畅</p>
</li>
</ul>
<h3 id="TensorFlow-2-0-eco-system"><a href="#TensorFlow-2-0-eco-system" class="headerlink" title="TensorFlow 2.0 eco-system"></a>TensorFlow 2.0 eco-system</h3><ul>
<li>TensorFlow 核心开源库 （本身）<ul>
<li>tf.function 方便的将动态图语言 转变为 静态图，某种程度上进行计算加速</li>
</ul>
</li>
<li>面向网页 JavaScript 的 TensorFlow.js</li>
<li>针对移动设备 和 IoT 的 TensorFlow Lite</li>
<li>面向工业部署的 TensorFlow Extended</li>
</ul>
<p>另外Google 开发了 针对 TensorFlow 的加速硬件 TPU</p>
<ul>
<li>TensorFlow Prob</li>
<li>TPU Cloud</li>
</ul>
<h3 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h3><ul>
<li>忘掉 1.x</li>
<li>PyTorch 和 TensorFlow 选一主修（融会贯通）<ul>
<li>二者都要掌握</li>
</ul>
</li>
<li>Keras 逐渐淡出<ul>
<li>TF + Keras<ul>
<li>tf.keras 本质上是 tf，只不过函数命名参考了 Keras 的命名方式，使用户使用更加方便</li>
</ul>
</li>
<li>PyTorch + Caffe2</li>
</ul>
</li>
</ul>
<blockquote>
<p>把时间放到 深度学习 算法上</p>
</blockquote>
<h3 id="why-TensorFlow"><a href="#why-TensorFlow" class="headerlink" title="why TensorFlow"></a>why TensorFlow</h3><ul>
<li><p>GPU加速</p>
</li>
<li><p>自动求导</p>
<p>不管网络多么深，参数多复杂，总是可以通过自动求导工具帮助我们精确的求出每个权值的梯度</p>
</li>
<li><p>神经网络 API</p>
</li>
</ul>
<h2 id="开发环境安装"><a href="#开发环境安装" class="headerlink" title="开发环境安装"></a>开发环境安装</h2><h3 id="Step1-Anaconda"><a href="#Step1-Anaconda" class="headerlink" title="Step1 Anaconda"></a>Step1 Anaconda</h3><h3 id="Step2-CUDA-10-0"><a href="#Step2-CUDA-10-0" class="headerlink" title="Step2 CUDA 10.0"></a>Step2 CUDA 10.0</h3><ul>
<li>NVIDIA显卡<ul>
<li>注意必须是 NVIDIA 显卡，其他的不能安装</li>
<li>后续安装 TensorFlow 必须用 CPU 版本，前期可以进行小案例的学习，后期稍微中型、大型的案例完全不能用 CPU 了，所以建议买一台 该显卡 的 电脑</li>
<li>选购<ul>
<li>GTX 1060 6GB（入门）</li>
<li>GTX 1080Ti 11GB</li>
<li>GTX 20系列性价比不行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Step3-TensorFlow安装"><a href="#Step3-TensorFlow安装" class="headerlink" title="Step3. TensorFlow安装"></a>Step3. TensorFlow安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cpu version</span></span><br><span class="line">$ pip install --upgrade tensorflow</span><br><span class="line"><span class="comment"># gpu version</span></span><br><span class="line">$ pip install --upgrade tensorflow-gpu</span><br></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="comment"># cpu版本测试</span></span><br><span class="line">tf.constant(<span class="number">1.</span>) + tf.constant(<span class="number">2.</span>) </span><br><span class="line"><span class="comment">#&lt;tf.Tensor: id=2, shape=(), dtype=float32, numpy=3.0&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gpu版本测试</span></span><br><span class="line">tf.test.is_gpu_available() <span class="comment"># True or False</span></span><br></pre></td></tr></table></figure>
<h2 id="TensorFlow-2-0-基本操作"><a href="#TensorFlow-2-0-基本操作" class="headerlink" title="TensorFlow 2.0 基本操作"></a>TensorFlow 2.0 基本操作</h2><h3 id="数据载体比较"><a href="#数据载体比较" class="headerlink" title="数据载体比较"></a>数据载体比较</h3><ul>
<li><p>list</p>
<p>存储空间大，处理效率低</p>
</li>
<li><p>np.array</p>
<ul>
<li>解决大数据的吞吐，对相同类型的数据，比较方便存储，做运算（转置，加减乘除）</li>
<li>致命弱点：深度学习之前就设计好的科学计算库，没有很好的GPU运算支持，不支持自动求导</li>
</ul>
</li>
<li><p>tf.Tensor</p>
<ul>
<li>地位跟 np.array 有些对等，拼接、分裂、stack操作、random操作类似，为了降低初学者难度，API设计与 NumPy 相近</li>
<li>更加注重神经网络计算</li>
<li>专门的数据载体，存储大量数据</li>
</ul>
</li>
</ul>
<h3 id="What-‘s-Tensor"><a href="#What-‘s-Tensor" class="headerlink" title="What ‘s Tensor"></a>What ‘s Tensor</h3><p>把数据叫为 Tensor</p>
<ul>
<li>scalar: 1.1 标量，准确的数据类型 (dim=0)</li>
<li>vector: [1.1], [1.1, 1.2]</li>
<li>matrix</li>
<li>tensor: $rank$ &gt; 2</li>
</ul>
<h3 id="Tensor-Flow-in-Graph"><a href="#Tensor-Flow-in-Graph" class="headerlink" title="Tensor Flow in Graph"></a>Tensor Flow in Graph</h3><p>名字由来：由于Tensor是数据的载体，非常形象的表明了在神经网络 / DP 中间自由的Flow</p>
<p>Tensor 经过不同的运算 在 网络中间 不停的流动，最终得到结果</p>
<h3 id="TF-is-computing-lib"><a href="#TF-is-computing-lib" class="headerlink" title="TF is computing lib"></a>TF is computing lib</h3><ul>
<li>int, float, double</li>
<li>bool ( eg. equal 返回 bool )</li>
<li>string</li>
</ul>
<h3 id="创建Tensor"><a href="#创建Tensor" class="headerlink" title="创建Tensor"></a>创建Tensor</h3><h4 id="From-NumPy，List"><a href="#From-NumPy，List" class="headerlink" title="From NumPy，List"></a>From NumPy，List</h4><p>现有的 NumPy ，list 转换得到</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.convert_to_tensor(np.ones([<span class="number">2</span>,<span class="number">3</span>]))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Tensor: id=134, shape=(2, 3), dtype=float64, numpy=</span></span><br><span class="line"><span class="string">array([[1., 1., 1.],</span></span><br><span class="line"><span class="string">       [1., 1., 1.]])&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">tf.convert_to_tensor(np.zeros([<span class="number">2</span>,<span class="number">3</span>]))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Tensor: id=143, shape=(2, 3), dtype=float64, numpy=</span></span><br><span class="line"><span class="string">array([[0., 0., 0.],</span></span><br><span class="line"><span class="string">       [0., 0., 0.]])&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p>传入 list 示例，list 必须是可以转化为 NumPy 的数据（逻辑上说得通）才能转化为 Tensor</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.convert_to_tensor([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=152, shape=(2,), dtype=int32, numpy=array([1, 2])&gt;</span></span><br><span class="line"></span><br><span class="line">tf.convert_to_tensor([<span class="number">1.</span>,<span class="number">2.</span>])</span><br><span class="line"><span class="comment">#&lt;tf.Tensor: id=161, shape=(2,), dtype=float32, numpy=array([1., 2.], dtype=float32)&gt;</span></span><br><span class="line"></span><br><span class="line">tf.convert_to_tensor([<span class="number">1</span>, <span class="number">2.</span>])</span><br><span class="line"><span class="comment">#&lt;tf.Tensor: id=179, shape=(2,), dtype=float32, numpy=array([1., 2.], dtype=float32)&gt;</span></span><br><span class="line"></span><br><span class="line">tf.convert_to_tensor([[<span class="number">1</span>],[<span class="number">2.</span>]])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Tensor: id=196, shape=(2, 1), dtype=float32, numpy=</span></span><br><span class="line"><span class="string">array([[1.],</span></span><br><span class="line"><span class="string">       [2.]], dtype=float32)&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错示例</span></span><br><span class="line">tf.convert_to_tensor([<span class="number">1</span>, (<span class="number">1</span>,<span class="number">2</span>)])</span><br><span class="line"><span class="comment"># ValueError: Can't convert Python sequence with mixed types to Tensor.</span></span><br></pre></td></tr></table></figure>
<p>convert_to_tensor 把 参数 理解成 data</p>
<h4 id="zeros-ones"><a href="#zeros-ones" class="headerlink" title="zeros, ones"></a>zeros, ones</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.zeros([]) <span class="comment"># scatter</span></span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=0, shape=(), dtype=float32, numpy=0.0&gt;</span></span><br><span class="line"></span><br><span class="line">tf.zeros([<span class="number">1</span>]) <span class="comment"># vector</span></span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=3, shape=(1,), dtype=float32, numpy=array([0.], dtype=float32)&gt;</span></span><br><span class="line"></span><br><span class="line">tf.zeros([<span class="number">2</span>,<span class="number">2</span>])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Tensor: id=6, shape=(2, 2), dtype=float32, numpy=</span></span><br><span class="line"><span class="string">array([[0., 0.],</span></span><br><span class="line"><span class="string">       [0., 0.]], dtype=float32)&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">tf.zeros([<span class="number">2</span>,<span class="number">1</span>]) <span class="comment"># 2行1列</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Tensor: id=9, shape=(2, 1), dtype=float32, numpy=</span></span><br><span class="line"><span class="string">array([[0.],</span></span><br><span class="line"><span class="string">       [0.]], dtype=float32)&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">tf.zeros([<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Tensor: id=12, shape=(2, 3, 3), dtype=float32, numpy=</span></span><br><span class="line"><span class="string">array([[[0., 0., 0.],</span></span><br><span class="line"><span class="string">        [0., 0., 0.],</span></span><br><span class="line"><span class="string">        [0., 0., 0.]],</span></span><br><span class="line"><span class="string">       [[0., 0., 0.],</span></span><br><span class="line"><span class="string">        [0., 0., 0.],</span></span><br><span class="line"><span class="string">        [0., 0., 0.]]], dtype=float32)&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">tf.ones([<span class="number">2</span>])</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=15, shape=(2,), dtype=float32, numpy=array([1., 1.], dtype=float32)&gt;</span></span><br></pre></td></tr></table></figure>
<p>zeros 和 ones 把 参数 理解为 shape</p>
<h4 id="zeros-like"><a href="#zeros-like" class="headerlink" title="zeros_like"></a>zeros_like</h4><p>直接根据传入 Tensor ，创建一个 同 shape 但元素全为0 的 Tensor</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.zeros_like(a)</span><br><span class="line"><span class="comment"># 等同，两个API通用</span></span><br><span class="line">tf.zeros(a.shape)</span><br></pre></td></tr></table></figure>
<p>ones_like 同理</p>
<h4 id="Fill"><a href="#Fill" class="headerlink" title="Fill"></a>Fill</h4><p>给 shape 填充 相同的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.fill([<span class="number">2</span>,<span class="number">3</span>], <span class="number">0</span>) <span class="comment"># 等同于 tf.zeros([2,3])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Tensor: id=18, shape=(2, 3), dtype=int32, numpy=</span></span><br><span class="line"><span class="string">array([[0, 0, 0],</span></span><br><span class="line"><span class="string">       [0, 0, 0]])&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">tf.fill([<span class="number">2</span>,<span class="number">3</span>], <span class="number">9</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Tensor: id=21, shape=(2, 3), dtype=int32, numpy=</span></span><br><span class="line"><span class="string">array([[9, 9, 9],</span></span><br><span class="line"><span class="string">       [9, 9, 9]])&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<blockquote>
<h5 id="tf-random-下的分布"><a href="#tf-random-下的分布" class="headerlink" title="tf.random 下的分布"></a>tf.random 下的分布</h5><ul>
<li>normal  |  正态分布</li>
<li>truncated_normal  |  截断的正态分布</li>
<li>uniform   |  均匀分布</li>
</ul>
</blockquote>
<h4 id="Normal"><a href="#Normal" class="headerlink" title="Normal"></a>Normal</h4><p>随机初始化，e.g.   w 和 b参数用正态分布或其他分布去初始化，一般 b 初始化为 0，w 可以初始化为 1，也可以随机。在DP中没这么简单，很多 paper 研究了不同的初始化方案对DP的性能，收敛速度都有显著影响。比如 xvier 有的较多，类似于某一种分布的初始化方案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.random.normal([<span class="number">2</span>,<span class="number">2</span>], mean=<span class="number">1</span>, stddev=<span class="number">1</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Tensor: id=27, shape=(2, 2), dtype=float32, numpy=</span></span><br><span class="line"><span class="string">array([[-0.29903114,  1.3298839 ],</span></span><br><span class="line"><span class="string">       [ 0.557529  ,  0.7930608 ]], dtype=float32)&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">tf.random.normal([<span class="number">2</span>,<span class="number">2</span>]) <span class="comment"># 默认是标准正态</span></span><br></pre></td></tr></table></figure>
<p><strong>truncated_normal 使用场景举例：</strong></p>
<p>在原有正态分布基础上，截去某一部分元素，如下图</p>
<p><img src="/images/truncated1.jpg" alt></p>
<p>把红色部分截去，在其他区域进行采样。</p>
<p>这样做的好处：在 Deep Learning 中，有 Sigmoid 激活函数 (类似生物学中S型曲线)，它有正态分布有交集，在横轴两侧，曲线区域梯度平缓，接近于0，这种现象称为 梯度弥散 or 梯度消失（Truncated Distribution）。这种现象出现时，更新会很困难。为了避免这种现象就引入了 truncated_normal ，性能比 normal 好一些。</p>
<h4 id="Uniform"><a href="#Uniform" class="headerlink" title="Uniform"></a>Uniform</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.random.uniform([<span class="number">2</span>,<span class="number">3</span>], minval = <span class="number">0</span>, maxval=<span class="number">100</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Tensor: id=34, shape=(2, 3), dtype=float32, numpy=</span></span><br><span class="line"><span class="string">array([[96.666954, 17.974722, 23.972082],</span></span><br><span class="line"><span class="string">       [62.272835, 95.62509 , 11.372995]], dtype=float32)&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">tf.random.uniform([<span class="number">2</span>,<span class="number">3</span>], minval = <span class="number">0</span>, maxval=<span class="number">100</span>, dtype=tf.int32)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Tensor: id=38, shape=(2, 3), dtype=int32, numpy=</span></span><br><span class="line"><span class="string">array([[57, 79, 37],</span></span><br><span class="line"><span class="string">       [37, 23, 29]])&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h4 id="Random-Permutation"><a href="#Random-Permutation" class="headerlink" title="Random Permutation"></a>Random Permutation</h4><p>小应用：随机打散，常用于 打散有对应关系的两个数据。比如 features 和 label 有 一一对应 关系，对 features 打散的时候，需要对 label 按照同样的顺序打散。这就需要相同的  index。</p>
<p>[64, 28, 28, 3] ： 64张照片，每张照片[28, 28, 3]，目的就是把照片顺序打乱</p>
<p>生成 0-63 索引，随机打散形成新的序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">idx = tf.range(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=42, shape=(10,), dtype=int32, numpy=array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;</span></span><br><span class="line"></span><br><span class="line">idx = tf.random.shuffle(idx)</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=43, shape=(10,), dtype=int32, numpy=array([0, 3, 4, 6, 8, 2, 9, 7, 1, 5])&gt;</span></span><br><span class="line"></span><br><span class="line">a = tf.random.normal([<span class="number">10</span>,<span class="number">784</span>])</span><br><span class="line">b = tf.random.uniform([<span class="number">10</span>], maxval=<span class="number">10</span>, dtype=tf.int32)</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=53, shape=(10,), dtype=int32, numpy=array([5, 5, 3, 5, 5, 2, 6, 5, 5, 1])&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用同样的 idx 从a和b中拿数据，这样就可以保证在经过随机后仍然保持对应关系</span></span><br><span class="line">a = tf.gather(a, idx)</span><br><span class="line">b = tf.gather(b, idx)</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=57, shape=(10,), dtype=int32, numpy=array([5, 5, 5, 6, 5, 3, 1, 5, 5, 2])&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="constant"><a href="#constant" class="headerlink" title="constant"></a>constant</h4><p>跟 convert_to_tensor 基本上完全重合，参数理解为 data，但维度必须一样</p>
<ul>
<li>constant 意思是不能改变，名字来源于 1.x 的，1.x中代表常量，现在就把它理解成一个普通的 Tensor</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建数据，类型取决于给定的参数 或者 手动给定</span></span><br><span class="line">tf.constant(<span class="number">1</span>) <span class="comment"># int32</span></span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=0, shape=(), dtype=int32, numpy=1&gt;</span></span><br><span class="line"></span><br><span class="line">tf.constant(<span class="number">1.</span>)</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=1, shape=(), dtype=float32, numpy=1.0&gt;</span></span><br><span class="line"></span><br><span class="line">tf.constant(<span class="number">2.</span>, dtype=tf.double)</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=2, shape=(), dtype=float64, numpy=2.0&gt;</span></span><br><span class="line"></span><br><span class="line">tf.constant([<span class="literal">True</span>, <span class="literal">False</span>])</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=3, shape=(2,), dtype=bool, numpy=array([ True, False])&gt;</span></span><br><span class="line"></span><br><span class="line">tf.constant(<span class="string">'hello,world.'</span>)</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=4, shape=(), dtype=string, numpy=b'hello,world.'&gt;</span></span><br></pre></td></tr></table></figure>
<p>错误示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.constant([[<span class="number">1</span>,<span class="number">2.</span>], [<span class="number">3.</span>]])</span><br><span class="line"><span class="comment"># ValueError: Can't convert non-rectangular Python sequence to Tensor.</span></span><br></pre></td></tr></table></figure>
<h4 id="Typecal-Dim-Data"><a href="#Typecal-Dim-Data" class="headerlink" title="Typecal Dim Data"></a>Typecal Dim Data</h4><p>不同 Tensor 的 shape 下的具体应用案例，帮助理解不同形状 Tensor</p>
<h5 id="Scalar-标量"><a href="#Scalar-标量" class="headerlink" title="Scalar |  标量"></a>Scalar |  标量</h5><ul>
<li>[]<ul>
<li>0</li>
<li>1.</li>
<li>2.2</li>
</ul>
</li>
<li>loss = mse(out, y)</li>
<li>accuracy</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比如4张照片，10类</span></span><br><span class="line"><span class="comment"># 这里out没有经过神经网络运算，用随机分布模拟</span></span><br><span class="line">out = tf.random.uniform([<span class="number">4</span>,<span class="number">10</span>])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Tensor: id=6, shape=(4, 10), dtype=float32, numpy=</span></span><br><span class="line"><span class="string">array([[0.9096954 , 0.49205315, 0.62928593, 0.6149267 , 0.6901686 ,</span></span><br><span class="line"><span class="string">        0.04514229, 0.1058538 , 0.84283805, 0.8563384 , 0.11697829],</span></span><br><span class="line"><span class="string">       [0.5169194 , 0.02506113, 0.5753865 , 0.39724565, 0.3482896 ,</span></span><br><span class="line"><span class="string">        0.55755997, 0.43404877, 0.5104655 , 0.19031775, 0.98010445],</span></span><br><span class="line"><span class="string">       [0.82540715, 0.10581172, 0.32901287, 0.38353086, 0.48970842,</span></span><br><span class="line"><span class="string">        0.85302186, 0.4669423 , 0.75125694, 0.08376086, 0.9594767 ],</span></span><br><span class="line"><span class="string">       [0.9461738 , 0.12383306, 0.88509655, 0.54084754, 0.5327699 ,</span></span><br><span class="line"><span class="string">        0.54813695, 0.32469988, 0.58895886, 0.26172686, 0.5735899 ]],</span></span><br><span class="line"><span class="string">      dtype=float32)&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假定 label 为0,1,2,3</span></span><br><span class="line">y = tf.range(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=10, shape=(4,), dtype=int32, numpy=array([0, 1, 2, 3])&gt;</span></span><br><span class="line">y = tf.one_hot(y, depth=<span class="number">10</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Tensor: id=14, shape=(4, 10), dtype=float32, numpy=</span></span><br><span class="line"><span class="string">array([[1., 0., 0., 0., 0., 0., 0., 0., 0., 0.],</span></span><br><span class="line"><span class="string">       [0., 1., 0., 0., 0., 0., 0., 0., 0., 0.],</span></span><br><span class="line"><span class="string">       [0., 0., 1., 0., 0., 0., 0., 0., 0., 0.],</span></span><br><span class="line"><span class="string">       [0., 0., 0., 1., 0., 0., 0., 0., 0., 0.]], dtype=float32)&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mse: (y-out)^2 累加求和</span></span><br><span class="line">loss = tf.keras.losses.mse(y, out)</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=17, shape=(4,), dtype=float32, numpy=array([0.29713577, 0.35845628, 0.39673066, 0.3338903 ], dtype=float32)&gt;</span></span><br><span class="line"></span><br><span class="line">loss = tf.reduce_mean(loss)</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=19, shape=(), dtype=float32, numpy=0.34655327&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="Vector-向量"><a href="#Vector-向量" class="headerlink" title="Vector | 向量"></a>Vector | 向量</h5><ul>
<li><p>Bias</p>
<ul>
<li>[out_dim]</li>
</ul>
<p>$y=x@w+b$，b 为 [10]，维度为1</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Dense层 8维 转化为 10维，功能都是维度变化</span></span><br><span class="line">net = tf.keras.layers.Dense(<span class="number">10</span>)</span><br><span class="line">net.build((<span class="number">4</span>,<span class="number">8</span>))</span><br><span class="line"><span class="comment"># kernel 初始化方法未知，可能是某种random</span></span><br><span class="line">net.kernel <span class="comment"># w 参数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Variable 'kernel:0' shape=(8, 10) dtype=float32, numpy=</span></span><br><span class="line"><span class="string">array([[-0.5167706 , -0.42759433,  0.27488554,  0.40619868, -0.16825691,</span></span><br><span class="line"><span class="string">        -0.53854436, -0.3289101 , -0.3599288 ,  0.312037  , -0.19269094],</span></span><br><span class="line"><span class="string">       [ 0.46941042,  0.4642514 ,  0.54453063,  0.34717393, -0.33969906,</span></span><br><span class="line"><span class="string">         0.20790648,  0.00850588, -0.51672363,  0.27600366,  0.45641685],</span></span><br><span class="line"><span class="string">       [ 0.34303325, -0.11325005, -0.21864352,  0.48297668, -0.12095174,</span></span><br><span class="line"><span class="string">         0.09572101, -0.40715218, -0.35717124, -0.20483121, -0.46552092],</span></span><br><span class="line"><span class="string">       [ 0.4865899 ,  0.05136955, -0.09178695,  0.17259252,  0.28631455,</span></span><br><span class="line"><span class="string">         0.2660445 , -0.41543508,  0.05910832, -0.19016105, -0.47269845],</span></span><br><span class="line"><span class="string">       [ 0.00252616, -0.12237576, -0.38564754,  0.1557622 , -0.49814075,</span></span><br><span class="line"><span class="string">         0.10102415,  0.08350313,  0.06122816,  0.30136532,  0.5090873 ],</span></span><br><span class="line"><span class="string">       [-0.14992028, -0.40108496,  0.32735962, -0.15980184,  0.16353315,</span></span><br><span class="line"><span class="string">         0.37525266, -0.35841423, -0.47843078,  0.35405552, -0.3584773 ],</span></span><br><span class="line"><span class="string">       [ 0.32667726,  0.40449303, -0.4557876 ,  0.44946396,  0.47827542,</span></span><br><span class="line"><span class="string">        -0.04340398,  0.49171865,  0.4222148 ,  0.11599368, -0.13451478],</span></span><br><span class="line"><span class="string">       [-0.28062007,  0.40846568, -0.3182774 ,  0.5397973 , -0.12705025,</span></span><br><span class="line"><span class="string">        -0.12112314, -0.49585712,  0.26155084,  0.11145604,  0.38149667]],</span></span><br><span class="line"><span class="string">      dtype=float32)&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># Dense layer初始化功能：将bias 这个Tensor 初始化为0</span></span><br><span class="line">net.bias <span class="comment"># b 参数</span></span><br><span class="line"><span class="comment"># &lt;tf.Variable 'bias:0' shape=(10,) dtype=float32, numpy=array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], dtype=float32)&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="Matrix-矩阵"><a href="#Matrix-矩阵" class="headerlink" title="Matrix | 矩阵"></a>Matrix | 矩阵</h5><ul>
<li><p>input x: [b, vec_dim]</p>
<p>多张照片 [b, 784]</p>
</li>
<li><p>weight: [input_dim, output_dim]</p>
<p>比如上述例子的 w [8, 10]</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 4张照片，每张照片是28*28打平</span></span><br><span class="line">x = tf.random.normal([<span class="number">4</span>,<span class="number">784</span>])</span><br><span class="line">x.shape <span class="comment"># TensorShape([4, 784])</span></span><br><span class="line"><span class="comment"># Dense层，维度为10，即 784-&gt;10 的过程</span></span><br><span class="line">net = tf.keras.layers.Dense(<span class="number">10</span>)</span><br><span class="line">net.build((<span class="number">4</span>,<span class="number">784</span>))</span><br><span class="line"><span class="comment"># 将x送到网络后，得到 [4,10]: 4张照片，每张照片输出shape是10</span></span><br><span class="line">net(x).shape <span class="comment"># TensorShape([4, 10])</span></span><br><span class="line"><span class="comment"># w 参数</span></span><br><span class="line">net.kernel.shape <span class="comment"># TensorShape([784, 10])</span></span><br><span class="line"><span class="comment"># b 参数</span></span><br><span class="line">net.bias.shape <span class="comment"># TensorShape([10])</span></span><br></pre></td></tr></table></figure>
<h5 id="Dim-3-Tensor"><a href="#Dim-3-Tensor" class="headerlink" title="Dim=3 Tensor"></a>Dim=3 Tensor</h5><p>在 NLP 方面用途广泛，NLP 中把每个单词转化为一个 向量</p>
<ul>
<li><p>x: [b, seq_len, word_dim]</p>
<ul>
<li>b |  句子个数</li>
<li>seq_len |  每个句子单词数量</li>
<li>word_dim |  单词编码长度</li>
</ul>
</li>
<li><p>I am a student. 可编码为 Tensor: [1, 5, 5] </p>
<p><img src="/images/NLP1.jpg" alt></p>
</li>
</ul>
<blockquote>
<p>imdb 电影评论数据，比如对xx的评价，有80个单词，label是好评or差评</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># imdb 电影评论数据</span></span><br><span class="line">(X_train, y_train), (X_test, y_test) = tf.keras.datasets.imdb.load_data(num_words=<span class="number">10000</span>)</span><br><span class="line"><span class="comment"># Downloading data from https://s3.amazonaws.com/text-datasets/imdb.npz</span></span><br><span class="line">x_train = tf.keras.preprocessing.sequence.pad_sequences(X_train, maxlen=<span class="number">80</span>)</span><br><span class="line">x_train.shape <span class="comment"># (25000, 80)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编码</span></span><br><span class="line">emb = embedding(x_train)</span><br><span class="line">emb.shape <span class="comment"># TensorShape([25000, 80, 100])  每个单词100维向量编码生成</span></span><br><span class="line"></span><br><span class="line">out = rnn(emb[:<span class="number">4</span>])</span><br><span class="line">out.shape <span class="comment"># TensorShape()</span></span><br></pre></td></tr></table></figure>
<h5 id="Dim-4-Tensor"><a href="#Dim-4-Tensor" class="headerlink" title="Dim=4 Tensor"></a>Dim=4 Tensor</h5><p>图片的一种保存方式，需要对几个简写非常敏感，做卷积神经网络时候用的特别多</p>
<ul>
<li>Image: [b, h, w, 3]<ul>
<li>MNIST: [b, 28, 28, 1]</li>
</ul>
</li>
<li>feature maps: [b, h, w, c]<ul>
<li>b  | 图片数量</li>
<li>h  |  height</li>
<li>w  | width</li>
<li>c  |  channel , RGB为3</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模拟4张照片</span></span><br><span class="line">x = tf.random.normal((<span class="number">4</span>,<span class="number">32</span>,<span class="number">32</span>,<span class="number">3</span>)) <span class="comment"># TensorShape([4, 32, 32, 3])</span></span><br><span class="line"><span class="comment"># 卷积层</span></span><br><span class="line">net = tf.keras.layers.Conv2D(<span class="number">16</span>, kernel_size=<span class="number">3</span>)</span><br><span class="line">net(x) <span class="comment"># [4, 32, 32, 16]</span></span><br><span class="line"><span class="comment"># tensorflow.python.framework.errors_impl.UnknownError: Failed to get convolution algorithm. This is probably because cuDNN failed to initialize, so try looking to see if a warning log message was printed above. [Op:Conv2D]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># channel 3 -&gt; 16</span></span><br></pre></td></tr></table></figure>
<h5 id="Dim-5-Tensor"><a href="#Dim-5-Tensor" class="headerlink" title="Dim=5 Tensor"></a>Dim=5 Tensor</h5><p>dim大于4的这种情况较少，dim=5 主要用于 meta-learning：把数据集分割为多个任务</p>
<ul>
<li><p>Single Task: [b, h, w, 3]</p>
</li>
<li><p>[t, b, h, w, c]</p>
<ul>
<li>t  |  任务数</li>
<li>[b, h, w, c]  |  Single Task</li>
</ul>
<p>训练时，比普通的卷积层多了新的维度（任务维度）</p>
</li>
</ul>
<p>维度再高的话比较少见</p>
<p>对于 Tensor 的理解：只要掌握了每一个维度的具体含义，就知道了Tensor代表什么类型数据存储，进行变换时，紧紧跟踪住每一个维度具体含义，这样就知道了这个维度做了何种运算，运算的具体含义是什么。</p>
<h3 id="Tensor-Property"><a href="#Tensor-Property" class="headerlink" title="Tensor Property"></a>Tensor Property</h3><ul>
<li>device</li>
<li>cpu()</li>
<li>gpu()</li>
<li>numpy()</li>
<li>shape</li>
<li>ndim</li>
<li>dtype | 数据类型</li>
<li><del>name</del> | 1.x遗留问题，并不需要这个属性</li>
<li>trainable |  </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对应环境下创建 Tensor</span></span><br><span class="line"><span class="keyword">with</span> tf.device(<span class="string">'cpu'</span>):</span><br><span class="line">    a=tf.constant([<span class="number">1</span>])</span><br><span class="line"><span class="keyword">with</span> tf.device(<span class="string">'gpu'</span>):</span><br><span class="line">    b=tf.range(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 查看 Tensor 所在设备的名称</span></span><br><span class="line">a.device <span class="comment"># '/job:localhost/replica:0/task:0/device:CPU:0'</span></span><br><span class="line">b.device <span class="comment"># '/job:localhost/replica:0/task:0/device:GPU:0'</span></span><br><span class="line"><span class="comment"># 切换设备，返回新的Tensor</span></span><br><span class="line">aa = a.gpu()</span><br><span class="line">aa.device <span class="comment"># '/job:localhost/replica:0/task:0/device:GPU:0'</span></span><br><span class="line"></span><br><span class="line">bb = b.cpu()</span><br><span class="line">bb.device <span class="comment"># '/job:localhost/replica:0/task:0/device:CPU:0'</span></span><br><span class="line"></span><br><span class="line">bnumpy = b.numpy() <span class="comment"># array([0, 1, 2, 3])</span></span><br><span class="line"></span><br><span class="line">b.shape <span class="comment"># TensorShape([4])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一般用 ndim 看维度</span></span><br><span class="line">b.ndim <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">tf.rank(b) <span class="comment"># &lt;tf.Tensor: id=12, shape=(), dtype=int32, numpy=1&gt;</span></span><br><span class="line"></span><br><span class="line">tf.rank(tf.ones([<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>])) <span class="comment"># &lt;tf.Tensor: id=16, shape=(), dtype=int32, numpy=3&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>CPU 和 GPU上的 Tensor 区别：对于GPU上的Tensor，只能使用 GPU 上的操作，但操作往往是自动判定的，操作符根据传入参数的 Tensor 进行自动选择 在对应设备 上进行操作，如果 Tensor 的设备不一致就会报错，需要将设备调整到一致。</p>
</blockquote>
<h3 id="Check-Tensor-Type"><a href="#Check-Tensor-Type" class="headerlink" title="Check Tensor Type"></a>Check Tensor Type</h3><p>使用场景：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="comment"># 先判断是不是Tensor，如果不是需要转化</span></span><br><span class="line">    <span class="comment"># 判断类型</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h4 id="判断一个变量是不是-Tensor"><a href="#判断一个变量是不是-Tensor" class="headerlink" title="判断一个变量是不是 Tensor"></a>判断一个变量是不是 Tensor</h4><ul>
<li>isinstance(var, tf.Tensor)<ul>
<li>Variable 的时候会返回 False</li>
</ul>
</li>
<li>tf.is_tensor(var) || 推荐使用！</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">isinstance(a, tf.Tensor) <span class="comment"># True</span></span><br><span class="line">tf.is_tensor(b) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<h4 id="判断-Tensor-类型"><a href="#判断-Tensor-类型" class="headerlink" title="判断 Tensor 类型"></a>判断 Tensor 类型</h4><ul>
<li>tf.float32</li>
<li>tf.string</li>
<li>tf.bool</li>
<li>……</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.dtype == tf.int32 <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<h4 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h4><ul>
<li>tf.convert_to_tensor(var, dtype) | numpy —&gt; Tensor</li>
<li>tf.cast(var, dtype)  |  Tensor 之间</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">5</span>) <span class="comment"># array([0, 1, 2, 3, 4])</span></span><br><span class="line">a.dtype <span class="comment"># dtype('int32')</span></span><br><span class="line">aa = tf.convert_to_tensor(a)</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=0, shape=(5,), dtype=int32, numpy=array([0, 1, 2, 3, 4])&gt;</span></span><br><span class="line"></span><br><span class="line">aa = tf.convert_to_tensor(a, dtype=tf.int64)</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=1, shape=(5,), dtype=int64, numpy=array([0, 1, 2, 3, 4], dtype=int64)&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bool类型转化很常见</span></span><br><span class="line">b = tf.constant([<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=2, shape=(2,), dtype=int32, numpy=array([0, 1])&gt;</span></span><br><span class="line">bb = tf.cast(b, dtype=tf.bool)</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=3, shape=(2,), dtype=bool, numpy=array([False,  True])&gt;</span></span><br><span class="line">tf.cast(bb, tf.int32)</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=4, shape=(2,), dtype=int32, numpy=array([0, 1])&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="tf-Variable"><a href="#tf-Variable" class="headerlink" title="tf.Variable"></a>tf.Variable</h3><p>特殊的数据类型，专门对于可以优化的参数</p>
<p>eg: $y=wx+b$,  x 和 y 都是 Tensor 类型， w 和 b 都是需要被优化的参数，除了是 Tensor 类型外，还有一个额外的属性 Variable </p>
<p>Tensor 经过 Variable 包装后，自动就具有了可求导的特性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.range(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=3, shape=(5,), dtype=int32, numpy=array([0, 1, 2, 3, 4])&gt;</span></span><br><span class="line"></span><br><span class="line">b = tf.Variable(a)</span><br><span class="line"><span class="comment"># &lt;tf.Variable 'Variable:0' shape=(5,) dtype=int32, numpy=array([0, 1, 2, 3, 4])&gt;</span></span><br><span class="line"></span><br><span class="line">b.name <span class="comment"># 'Variable:0'</span></span><br><span class="line">b.trainable <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">isinstance(b, tf.Tensor) <span class="comment"># False</span></span><br><span class="line">isinstance(b, tf.Variable) <span class="comment"># True</span></span><br><span class="line">tf.is_tensor(b) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p>trainable 是 告诉 网络/计算图 进行 先后传播/求导 需要对 b 这个参数 进行求导，需要梯度信息，即$\frac{\partial loss}{\part w}$ 这样一个过程，如果不转化的话也可以，但需要额外指定 这张图 需要对这个 Tensor 观察，不然它不会对该 Tensor 不会进行跟梯度信息相关的跟踪（后续会实例讲解哪些需要 watch，哪些需要转化为 Variable）。</p>
<p>当转化为 Variable 后会自动记录 梯度相关信息，该类型专为神经网络参数设计，是对Tensor的一个包装。</p>
<h3 id="To-numpy"><a href="#To-numpy" class="headerlink" title="To numpy"></a>To numpy</h3><p>Tensor 数据转化为 numpy</p>
<p>在运行中间，Tensor 一般是在GPU上，当需要在CPU上进行一些额外的控制逻辑时，需要把数据取回到CPU上，得到具体的数据（调用 numpy 方法）</p>
<p>对于标量型的，还有更简单的，直接用 int(), float() 即可，前提是该 Tensor 是 Scatter</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.ones([])</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=85, shape=(), dtype=float32, numpy=1.0&gt;</span></span><br><span class="line">a.numpy() <span class="comment"># 1.0</span></span><br><span class="line">int(a) <span class="comment"># 1</span></span><br><span class="line">float(a) <span class="comment"># 1.0</span></span><br></pre></td></tr></table></figure>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>读取 Tensor 单个数据，每个维度指定一个数值</p>
<h4 id="Basic-indexing"><a href="#Basic-indexing" class="headerlink" title="Basic indexing"></a>Basic indexing</h4><p>最基本的索引方式，逐渐给出外层的 idx</p>
<ul>
<li>支持索引方式单一</li>
<li>需要写多个 []，可读性不强</li>
<li>只能取 1 个元素，不能隔断取，倒着取</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Basic indexing</span></span><br><span class="line">a = tf.ones([<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">3</span>]) <span class="comment"># TensorShape([1, 5, 5, 3])</span></span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Tensor: id=10, shape=(5, 3), dtype=float32, numpy=</span></span><br><span class="line"><span class="string">array([[1., 1., 1.],</span></span><br><span class="line"><span class="string">       [1., 1., 1.],</span></span><br><span class="line"><span class="string">       [1., 1., 1.],</span></span><br><span class="line"><span class="string">       [1., 1., 1.],</span></span><br><span class="line"><span class="string">       [1., 1., 1.]], dtype=float32)&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=22, shape=(3,), dtype=float32, numpy=array([1., 1., 1.], dtype=float32)&gt;</span></span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=38, shape=(), dtype=float32, numpy=1.0&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="NumPy-style-indexing"><a href="#NumPy-style-indexing" class="headerlink" title="NumPy-style indexing"></a>NumPy-style indexing</h4><p>NumPy 对索引方式进行了很好的拓展：所有编号写一起，中间用逗号隔开</p>
<ul>
<li>少写很多 []</li>
<li>程序可读性强</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># NumPy-style indexing</span></span><br><span class="line">a = tf.random.normal([<span class="number">4</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">3</span>]) <span class="comment"># 可理解成 4张28*28的彩色照片</span></span><br><span class="line">a[<span class="number">1</span>].shape <span class="comment"># TensorShape([28, 28, 3])  第2张照片</span></span><br><span class="line">a[<span class="number">1</span>,<span class="number">2</span>].shape <span class="comment"># 同 a[1][2]，但不推荐</span></span><br><span class="line"><span class="comment"># TensorShape([28, 3]) 第2张照片第3行：每一行包含了28列，每一列有3个RGB数值</span></span><br><span class="line">a[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].shape</span><br><span class="line"><span class="comment"># TensorShape([3]) 第2张照片第3行第4列：具体的RGB数值</span></span><br><span class="line">a[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"> &lt;tf.Tensor: id=74, shape=(3,), dtype=float32, numpy=array([ 0.11981988,  0.94879496, -0.42506   ], dtype=float32)&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">a[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>].shape</span><br><span class="line"><span class="comment"># TensorShape([]) 第2张照片第3行第4列 B通道：蓝色通道色素的值(0-255或归一化)</span></span><br><span class="line">a[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=94, shape=(), dtype=float32, numpy=-0.42506&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>读取 Tensor 某维度的一部分</p>
<h4 id="start-end"><a href="#start-end" class="headerlink" title="start:end"></a>start:end</h4><p>包含 start, 不含索引 end。默认为 </p>
<ul>
<li>[:]  =&gt;  所有元素都取</li>
<li>start 默认为0开始，包含</li>
<li>end 如果不指定 则 取到末尾，如果指定，取到 end-1 位置结束</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.range(<span class="number">10</span>)</span><br><span class="line"><span class="comment">#  &lt;tf.Tensor: id=3, shape=(10,), dtype=int32, numpy=array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意细微区别</span></span><br><span class="line">a[<span class="number">-1</span>:] <span class="comment"># &lt;tf.Tensor: id=7, shape=(1,), dtype=int32, numpy=array([9])&gt;</span></span><br><span class="line">a[<span class="number">-1</span>]  <span class="comment"># &lt;tf.Tensor: id=15, shape=(), dtype=int32, numpy=9&gt;</span></span><br><span class="line">a[<span class="number">-2</span>:] <span class="comment"># &lt;tf.Tensor: id=11, shape=(2,), dtype=int32, numpy=array([8, 9])&gt;</span></span><br><span class="line">a[:<span class="number">2</span>]  <span class="comment"># &lt;tf.Tensor: id=23, shape=(2,), dtype=int32, numpy=array([0, 1])&gt;</span></span><br><span class="line">a[:<span class="number">-1</span>] <span class="comment"># &lt;tf.Tensor: id=19, shape=(9,), dtype=int32, numpy=array([0, 1, 2, 3, 4, 5, 6, 7, 8])&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.random.normal([<span class="number">4</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">3</span>]) <span class="comment"># TensorShape([4, 28, 28, 3])</span></span><br><span class="line">a[<span class="number">0</span>].shape <span class="comment"># TensorShape([28, 28, 3])</span></span><br><span class="line"><span class="comment"># a[0]等价写法： a[0,:,:,:]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取所有图片，所有行所有列的 R 通道，这种情况不使用切片无法完成</span></span><br><span class="line">a[:,:,:,<span class="number">0</span>].shape <span class="comment"># TensorShape([4, 28, 28])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可对中间某维度进行切片，之后维度全部都取可以不写</span></span><br><span class="line">a[:,<span class="number">0</span>:<span class="number">2</span>].shape <span class="comment"># TensorShape([4, 2, 28, 3])</span></span><br><span class="line">a[:,<span class="number">0</span>:<span class="number">2</span>,:].shape <span class="comment"># TensorShape([4, 2, 28, 3]) </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取所有图片，所有行所有列的 Blue 通道</span></span><br><span class="line">a[:,:,:,<span class="number">2</span>].shape <span class="comment"># TensorShape([4, 28, 28])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4张图片 第1行 所有列所有通道</span></span><br><span class="line">a[:,<span class="number">0</span>,:,:].shape <span class="comment"># TensorShape([4, 28, 3])</span></span><br></pre></td></tr></table></figure>
<p>冒号这种索引方式会很丰富</p>
<h4 id="start-end-step"><a href="#start-end-step" class="headerlink" title="start: end: step"></a>start: end: step</h4><p>在上一小节基础上，加入步长的概念，step省略的情况（step为1）下回到了单冒号的情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.random.normal([<span class="number">4</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">3</span>]) <span class="comment"># TensorShape([4, 28, 28, 3])</span></span><br><span class="line">a.shape <span class="comment"># TensorShape([4, 28, 28, 3])</span></span><br><span class="line">a[<span class="number">0</span>:<span class="number">2</span>,:,:,:].shape <span class="comment"># TensorShape([2, 28, 28, 3])</span></span><br><span class="line">a[:,<span class="number">0</span>:<span class="number">28</span>:<span class="number">2</span>,<span class="number">0</span>:<span class="number">28</span>:<span class="number">2</span>,:].shape <span class="comment"># TensorShape([4, 14, 14, 3])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取图像的左上方</span></span><br><span class="line">a[:,:<span class="number">14</span>,:<span class="number">14</span>,:].shape <span class="comment"># TensorShape([4, 14, 14, 3])</span></span><br><span class="line"><span class="comment"># 取图像的右下方</span></span><br><span class="line">a[:,<span class="number">14</span>:,<span class="number">14</span>:,:].shape <span class="comment"># TensorShape([4, 14, 14, 3])</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">a[:,::<span class="number">2</span>,::<span class="number">2</span>,:].shape <span class="comment"># TensorShape([4, 14, 14, 3])</span></span><br><span class="line"><span class="comment"># 去除边缘，对中间部分进行采样</span></span><br><span class="line">a[:,<span class="number">2</span>:<span class="number">26</span>:<span class="number">2</span>,<span class="number">2</span>:<span class="number">26</span>:<span class="number">2</span>,:].shape <span class="comment"># TensorShape([4, 12, 12, 3])</span></span><br></pre></td></tr></table></figure>
<h4 id="1"><a href="#1" class="headerlink" title="::-1"></a>::-1</h4><p>逆序功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.range(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=3, shape=(4,), dtype=int32, numpy=array([0, 1, 2, 3])&gt;</span></span><br><span class="line">a[::<span class="number">-1</span>]</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=7, shape=(4,), dtype=int32, numpy=array([3, 2, 1, 0])&gt;</span></span><br><span class="line">a[::<span class="number">-2</span>]</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=11, shape=(2,), dtype=int32, numpy=array([3, 1])&gt;</span></span><br><span class="line">a[<span class="number">2</span>::<span class="number">-2</span>]</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=15, shape=(2,), dtype=int32, numpy=array([2, 0])&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="…"><a href="#…" class="headerlink" title="…"></a>…</h4><p>…表示其所代表的维度都取，只要能从逻辑上推断出 … 代表哪些维度，就可以使用</p>
<p>[x,…,y]，y只能代表最后的维度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加task维度</span></span><br><span class="line">a = tf.random.normal([<span class="number">2</span>,<span class="number">4</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment"># 等价写法1, 以下均为 TensorShape([4, 28, 28, 3])</span></span><br><span class="line">a[<span class="number">0</span>].shape</span><br><span class="line">a[<span class="number">0</span>,:,:,:,:].shape</span><br><span class="line">a[<span class="number">0</span>,::,::,::,::].shape</span><br><span class="line"><span class="comment"># 引入省略号实现等价写法1</span></span><br><span class="line">a[<span class="number">0</span>,...].shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价写法2, TensorShape([2, 4, 28, 28])</span></span><br><span class="line">a[:,:,:,:,<span class="number">0</span>].shape</span><br><span class="line">a[...,<span class="number">0</span>].shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价写法3, TensorShape([4, 28, 28])</span></span><br><span class="line">a[<span class="number">0</span>,:,:,:,<span class="number">2</span>].shape</span><br><span class="line">a[<span class="number">0</span>,...,<span class="number">2</span>].shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价写法4, TensorShape([28, 28])</span></span><br><span class="line">a[<span class="number">1</span>,<span class="number">0</span>,:,:,<span class="number">0</span>].shape</span><br><span class="line">a[<span class="number">1</span>,<span class="number">0</span>,...,<span class="number">0</span>].shape</span><br></pre></td></tr></table></figure>
<h3 id="Selective-Indexing"><a href="#Selective-Indexing" class="headerlink" title="Selective Indexing"></a>Selective Indexing</h3><p>无上述所述的规律，随意采样。顺序由自己定！灵活性很强</p>
<h4 id="tf-gather"><a href="#tf-gather" class="headerlink" title="tf.gather"></a>tf.gather</h4><p>收集功能：给定 索引 收集对应维度上 索引所在的的元素（单维度上可以DIY）</p>
<ul>
<li>data: [classes, students, subjects]  e.g. [4, 35, 8]</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.random.uniform([<span class="number">4</span>,<span class="number">35</span>,<span class="number">8</span>], maxval=<span class="number">100</span>, dtype=tf.int32)</span><br><span class="line"><span class="comment"># 以下两种写法等价</span></span><br><span class="line">a[<span class="number">2</span>:<span class="number">4</span>].shape <span class="comment"># TensorShape([2, 35, 8])</span></span><br><span class="line">tf.gather(a, axis=<span class="number">0</span>, indices=[<span class="number">2</span>,<span class="number">3</span>]).shape <span class="comment"># TensorShape([2, 35, 8])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">a 为数据源</span></span><br><span class="line"><span class="string">axis=0 表示 取 classes 这个维度</span></span><br><span class="line"><span class="string">indices 给出取该维度具体的索引号</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 打散4个班的顺序</span></span><br><span class="line">tf.gather(a, axis=<span class="number">0</span>, indices=[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>]).shape <span class="comment"># TensorShape([4, 35, 8])</span></span><br><span class="line"><span class="comment"># 对每个班抽样检查,抽取 指定索引学生(index顺序自己定) 的所有课程成绩</span></span><br><span class="line">tf.gather(a, axis=<span class="number">1</span>, indices=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">16</span>]).shape <span class="comment"># TensorShape([4, 5, 8])</span></span><br><span class="line"><span class="comment"># 查看所有班级 所有学生 指定科目的成绩</span></span><br><span class="line">tf.gather(a, axis=<span class="number">2</span>, indices=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>]).shape <span class="comment"># TensorShape([4, 35, 3])</span></span><br></pre></td></tr></table></figure>
<h4 id="tf-gather-nd"><a href="#tf-gather-nd" class="headerlink" title="tf.gather_nd"></a>tf.gather_nd</h4><p>What if sample several students and their several subjects?</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 串行通过两个 gather 实现</span></span><br><span class="line">aa = tf.gather(a, axis, [several students])</span><br><span class="line">aaa = tf.gather(aa, axis, [several subjects])</span><br></pre></td></tr></table></figure>
<p>What if sample several (classes and student)?  </p>
<ul>
<li>e.g. 2—0,  3—4,  8—2</li>
<li>[class1_student1, class2_student2, class3_student3, class4_student4] ,其shape [4,8]</li>
</ul>
<p>上述需求需要 同时在多个维度上 指定 idx</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.random.uniform([<span class="number">4</span>,<span class="number">35</span>,<span class="number">8</span>], maxval=<span class="number">100</span>, dtype=tf.int32)</span><br><span class="line">a.shape <span class="comment"># TensorShape([4, 35, 8])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0号班级所有成绩</span></span><br><span class="line">tf.gather_nd(a, [<span class="number">0</span>]).shape <span class="comment"># TensorShape([35, 8]), 相当于 a[0]</span></span><br><span class="line">tf.gather_nd(a, [[<span class="number">0</span>]]).shape <span class="comment"># TensorShape([1, 35, 8])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0号班级 1号学生 所有成绩</span></span><br><span class="line">tf.gather_nd(a, [<span class="number">0</span>,<span class="number">1</span>]).shape <span class="comment"># TensorShape([8]), 相当于a[0,1]</span></span><br><span class="line">tf.gather_nd(a, [[<span class="number">0</span>,<span class="number">1</span>]]).shape <span class="comment"># TensorShape([1, 8])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0号班级 1号学生 2号课程 的成绩</span></span><br><span class="line">tf.gather_nd(a, [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]).shape <span class="comment"># TensorShape([])</span></span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=33, shape=(), dtype=int32, numpy=11&gt;</span></span><br><span class="line">tf.gather_nd(a, [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]]).shape <span class="comment"># TensorShape([1])</span></span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=31, shape=(1,), dtype=int32, numpy=array([11])&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">tf.gather_nd(a, [[<span class="number">0</span>,<span class="number">0</span>], [<span class="number">1</span>,<span class="number">1</span>]]).shape <span class="comment"># TensorShape([2, 8])</span></span><br><span class="line">tf.gather_nd(a, [[<span class="number">0</span>,<span class="number">0</span>], [<span class="number">1</span>,<span class="number">1</span>], [<span class="number">2</span>,<span class="number">2</span>]]).shape <span class="comment"># TensorShape([3, 8])</span></span><br><span class="line">tf.gather_nd(a, [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]]).shape <span class="comment"># TensorShape([3])</span></span><br><span class="line">tf.gather_nd(a, [[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]]]).shape <span class="comment"># TensorShape([1, 3])</span></span><br></pre></td></tr></table></figure>
<ul>
<li>最内层作为整体来看</li>
<li>recommend indices format:<ul>
<li>[[0], [1], …]</li>
<li>[[0,0], [1,1], …]</li>
<li>[[0,0,0], [1,1,1], …]</li>
</ul>
</li>
</ul>
<p>如果理解上有困难可以跳过，部分关键代码会用到</p>
<h4 id="tf-boolean-mask"><a href="#tf-boolean-mask" class="headerlink" title="tf.boolean_mask"></a>tf.boolean_mask</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.random.normal([<span class="number">4</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">3</span>]) <span class="comment"># TensorShape([4, 28, 28, 3])</span></span><br><span class="line">tf.boolean_mask(a, mask=[<span class="literal">True</span>,<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">False</span>]).shape <span class="comment"># TensorShape([2, 28, 28, 3])</span></span><br><span class="line">tf.boolean_mask(a, mask=[<span class="literal">True</span>,<span class="literal">True</span>, <span class="literal">False</span>], axis=<span class="number">3</span>).shape <span class="comment"># TensorShape([4, 28, 28, 2])</span></span><br><span class="line"></span><br><span class="line">a = tf.ones([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">tf.boolean_mask(a, mask=[[<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">False</span>],[<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">True</span>]])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Tensor: id=93, shape=(3, 4), dtype=float32, numpy=</span></span><br><span class="line"><span class="string">array([[1., 1., 1., 1.],</span></span><br><span class="line"><span class="string">       [1., 1., 1., 1.],</span></span><br><span class="line"><span class="string">       [1., 1., 1., 1.]], dtype=float32)&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 这里是 3是匹配到了多少个True</span></span><br></pre></td></tr></table></figure>
<p>只给出一个维度的情况：mask 为True时取出来</p>
<h3 id="维度变换"><a href="#维度变换" class="headerlink" title="维度变换"></a>维度变换</h3><p>[b, 28, 28, 1] 中，每一个数字代表一个轴(axis)，这个 Tensor 维度是 4维。数字本身代表 长度，也就是每个axis的shape。我们可以做一些不同理解上的变换（reshape）</p>
<p>另外还有 增加/减少 1个维度；对维度的先后顺序进行变换</p>
<h4 id="View-amp-Reshape"><a href="#View-amp-Reshape" class="headerlink" title="View &amp; Reshape"></a>View &amp; Reshape</h4><p>视图的概念：</p>
<p>[b, 28, 28] 中的照片在内存中先保存第1行，第2行……行优先，列为次。对于这一组内存中连续的数据可以作不同的理解</p>
<ul>
<li>每一张图片，每个图片28行，每一行28列，跟 content 理解一致</li>
<li>[b, 28*28] : 把28*28理解为整体，失去行列信息<ul>
<li>全连接层的使用方式：不关注二维信息</li>
</ul>
</li>
<li>[b, 2, 14*28] : 把图片分成上下两部分，每部分不区分行列</li>
<li>[b, 28, 28, 1] : 增加 channel，跟view1 差不多 </li>
</ul>
<p>对数据没有破坏/扰动，只不过按照不同的方式去理解，每种理解方式成为一个 view，具体物理意义取决于你。content 在这个过程中保持不变，就是最初的 view</p>
<p>reshape 操作是灵活的，保证size相同即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.random.normal([<span class="number">4</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">3</span>])</span><br><span class="line">a.shape <span class="comment"># TensorShape([4, 28, 28, 3])</span></span><br><span class="line">a.ndim <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把长和宽概念抹去，合并为像素(pixel)的概念</span></span><br><span class="line">tf.reshape(a, [<span class="number">4</span>,<span class="number">784</span>,<span class="number">3</span>]).shape <span class="comment"># TensorShape([4, 784, 3])</span></span><br><span class="line"><span class="comment"># 一个新的view 只能有一个 -1，-1位置会根据其他参数自动计算合理的值</span></span><br><span class="line">tf.reshape(a, [<span class="number">4</span>,<span class="number">-1</span>,<span class="number">3</span>]).shape <span class="comment"># TensorShape([4, 784, 3])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pixel 和 channel 合并，物理含义：data point</span></span><br><span class="line"><span class="comment"># 无法恢复 channel 信息</span></span><br><span class="line">tf.reshape(a, [<span class="number">4</span>,<span class="number">784</span>*<span class="number">3</span>]).shape <span class="comment"># TensorShape([4, 2352])</span></span><br><span class="line">tf.reshape(a, [<span class="number">4</span>,<span class="number">-1</span>]).shape <span class="comment"># TensorShape([4, 2352])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># flexible</span></span><br><span class="line">tf.reshape(tf.reshape(a,[<span class="number">4</span>,<span class="number">-1</span>]),[<span class="number">4</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">3</span>]).shape</span><br><span class="line">tf.reshape(tf.reshape(a,[<span class="number">4</span>,<span class="number">-1</span>]),[<span class="number">4</span>,<span class="number">14</span>,<span class="number">56</span>,<span class="number">3</span>]).shape</span><br><span class="line">tf.reshape(tf.reshape(a,[<span class="number">4</span>,<span class="number">-1</span>]),[<span class="number">4</span>,<span class="number">1</span>,<span class="number">784</span>,<span class="number">3</span>]).shape</span><br></pre></td></tr></table></figure>
<p>在数据在内存中的分布不变的情况下，只要你觉得reshape操作有含义，满足目的即可。</p>
<p>潜在的bug:</p>
<ul>
<li>[4,28,28,3] reshape to [4,784,3] 的时候，需要额外知道 height:28, width:28 的信息(content)才能恢复出来。</li>
<li>14*56</li>
<li>width 和 height 顺序记错</li>
</ul>
<h4 id="content-amp-transpose"><a href="#content-amp-transpose" class="headerlink" title="content &amp; transpose"></a>content &amp; transpose</h4><p>如果想把 维度 axis 进行交换（交换 content 顺序），可通过<code>tf.transpose</code> 实现。如 [b,h,w,c] 转为 [b,w,h,c]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.random.normal((<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line">a.shape <span class="comment"># TensorShape([4, 3, 2, 1])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认的转置方式</span></span><br><span class="line">tf.transpose(a).shape <span class="comment"># TensorShape([1, 2, 3, 4])</span></span><br><span class="line"><span class="comment"># 指定参数</span></span><br><span class="line">tf.transpose(a, perm=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]).shape <span class="comment"># TensorShape([4, 3, 1, 2])</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">小实例：pytorch 中 存储格式 为 [b,3,h,w] , 而 TensorFlow 中为 [b,h,w,c]。如果要进行数据互通，需要把数据存储格式content转换</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># [b,h,w,c]</span></span><br><span class="line">a = tf.random.normal([<span class="number">4</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment"># [b,w,h,c]</span></span><br><span class="line">tf.transpose(a, [<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]).shape <span class="comment"># TensorShape([4, 28, 28, 3])</span></span><br><span class="line"><span class="comment"># pytorch的格式，但被转置了</span></span><br><span class="line">tf.transpose(a, [<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]).shape <span class="comment"># TensorShape([4, 3, 28, 28])</span></span><br><span class="line"><span class="comment"># 正确做法</span></span><br><span class="line">tf.transpose(a, [<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]).shape <span class="comment"># TensorShape([4, 3, 28, 28])</span></span><br></pre></td></tr></table></figure>
<h4 id="Squeeze-VS-Expand-dims"><a href="#Squeeze-VS-Expand-dims" class="headerlink" title="Squeeze VS Expand_dims"></a>Squeeze VS Expand_dims</h4><p>增加或减少维度，本质上也是改变view</p>
<h5 id="Expand-dim"><a href="#Expand-dim" class="headerlink" title="Expand dim"></a>Expand dim</h5><ul>
<li>a: [classes, students, classes]</li>
<li>add school dim(=axis)</li>
<li>[1,4,35,8] + [1,4,35,8] = [2,4,35,8]  (数据合并)</li>
<li><code>tf.expand_dims</code> 增加位置规律：<ul>
<li>当 <code>axis</code> 非负数，增加后的维度 在此位置，即加到 原来这个axis的前面</li>
<li>当 <code>axis</code> 为负数，加到 原来位置 的后面</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.random.normal([<span class="number">4</span>,<span class="number">35</span>,<span class="number">8</span>])</span><br><span class="line"></span><br><span class="line">tf.expand_dims(a, axis=<span class="number">0</span>).shape <span class="comment"># TensorShape([1, 4, 35, 8])</span></span><br><span class="line">tf.expand_dims(a, axis=<span class="number">-4</span>).shape <span class="comment"># TensorShape([1, 4, 35, 8])</span></span><br><span class="line"></span><br><span class="line">tf.expand_dims(a, axis=<span class="number">3</span>).shape <span class="comment"># TensorShape([4, 35, 8, 1])</span></span><br><span class="line">tf.expand_dims(a, axis=<span class="number">-1</span>).shape <span class="comment"># TensorShape([4, 35, 8, 1])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下仅供示范</span></span><br><span class="line">tf.expand_dims(a, axis=<span class="number">1</span>).shape  <span class="comment"># TensorShape([4, 1, 35, 8])</span></span><br><span class="line">tf.expand_dims(a, axis=<span class="number">-2</span>).shape <span class="comment"># TensorShape([4, 35, 1, 8])</span></span><br></pre></td></tr></table></figure>
<h5 id="Squeeze-dim"><a href="#Squeeze-dim" class="headerlink" title="Squeeze dim"></a>Squeeze dim</h5><ul>
<li>Only squeeze for shape=1 dim<ul>
<li>[4, 35, 8, <font color="red">1</font>]</li>
<li>[<font color="red">1</font>, 4, 35, 8]</li>
<li>[<font color="red">1</font>, 4, 35, <font color="red">1</font>]</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对于所有shape=1 的 axis 可以全部去掉(squeeze)</span></span><br><span class="line">tf.squeeze(tf.zeros([<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>])).shape <span class="comment"># TensorShape([2, 3])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 axis 进行擦除dim</span></span><br><span class="line">a = tf.zeros([<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>])</span><br><span class="line">tf.squeeze(a, axis=<span class="number">0</span>).shape <span class="comment"># TensorShape([2, 1, 3])</span></span><br><span class="line">tf.squeeze(a, axis=<span class="number">-4</span>).shape <span class="comment"># TensorShape([2, 1, 3])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 并不存在 在前/在后 擦除的 区别，axis必须存在</span></span><br><span class="line">tf.squeeze(a, axis=<span class="number">2</span>).shape <span class="comment"># TensorShape([1, 2, 3])</span></span><br><span class="line">tf.squeeze(a, axis=<span class="number">-2</span>).shape <span class="comment"># TensorShape([1, 2, 3])</span></span><br></pre></td></tr></table></figure>
<h3 id="Broadcasting"><a href="#Broadcasting" class="headerlink" title="Broadcasting"></a>Broadcasting</h3><blockquote>
<p>背景：$x@w+b$ 在shape上体现就是 [b,784]@[784,10] + [10]；最后一步 + [10] 需要扩张 [b,10]才可以</p>
</blockquote>
<ul>
<li>Expand<ul>
<li><code>tf.broadcast_to</code> 张量的维度扩张的手段，对某一个维度上重复n多次，但并没有真正的复制数据<ul>
<li>可理解为优化的手段，没有复制数据，但呈现出来数据被扩张了。</li>
</ul>
</li>
<li><code>tf.tile</code> 是显式复制数据，对某个维度重复n多次，并且真实的在数据上体现出来</li>
</ul>
</li>
<li>Key idea<ul>
<li>Insert 1 dim ahead if needed</li>
<li>Expand dims with size 1 to same size</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># For example</span></span><br><span class="line"><span class="string">Feature</span> <span class="attr">maps:</span> <span class="string">[4,32,32,3]</span></span><br><span class="line"><span class="attr">Bias:</span> <span class="string">[3]-&gt;</span> <span class="string">[1,1,1,32]</span> <span class="bullet">-&gt;</span> <span class="string">[4,32,32,3]</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/Broadcasting-1.jpg" alt></p>
<p>[4] + [1,3] 右边对齐，插入维度后是 [1,4] vs. [1,3] , 3 和 4 不相等，两者之中有1的话可以扩张成相同的维度。无法进行 broadcasting</p>
<h4 id="How-to-understand"><a href="#How-to-understand" class="headerlink" title="How to understand?"></a>How to understand?</h4><ul>
<li><p>When it has no axis</p>
<ul>
<li>Create a new concept</li>
<li>[classes, students, scores] + [scores]</li>
</ul>
<p>理解：维度有大小之分，大维度概念更加高层、抽象（比如class &gt; student &gt; score [4,35,8]），小维度更加底层。给定小维度的配置（score的偏置 [8]），默认对所有高纬度概念通用（自动的将[8] 扩张 为 [1,1,8] 再扩张为 [4,35,8]，对原来的数据都按照这样一个偏置进行叠加）</p>
</li>
<li><p>When it has dim of size 1</p>
<ul>
<li>Treat it shared by all</li>
<li>[classes, students, scores] + [students, 1]</li>
</ul>
<p>理解：对于Data: [4,35,8]，对于[35,1] （对于班级上残疾学生，编号为0 ?……）希望对他们有一些偏置（每一门课都加5分）,35表现为 [5,5,0,0,……] (对 所有班级里 前两个学生 的  所有成绩  加5分，表示为[35,1]，即给出35个学生具体的偏置科目，这个偏置对所有科目适用)，把[35,1] 扩张为 [1,35,1] ，再复制为 [4,35,8]，即偏置对所有科目适用，这个偏置对所有班级适用，具体偏置取决于 35 的数据</p>
</li>
</ul>
<h4 id="Why-broadcasting"><a href="#Why-broadcasting" class="headerlink" title="Why broadcasting?"></a>Why broadcasting?</h4><p>[b,10] + [10] 这个过程，可以显示的通过 expend_dim, tf.tile 操作完成数据的扩张，如果遵循大小维度的概念，如果大维度是通用的约定的话，broadcasting 会非常简洁</p>
<ul>
<li><p>for real demanding</p>
<p>默认大维度是更加高层的概念，如果没有写高纬度的配置，则默认高纬度所有维度都适用</p>
<ul>
<li><p>[classes, students, scores]</p>
</li>
<li><p>Add bias for every student:  + 5 score</p>
<ul>
<li><p>[4,32,8]  + [4,32,8]</p>
</li>
<li><p>[4,32,8] +<font color="red"> [5.0] </font></p>
<p>[5.0] 的 shape 为 [1] 会扩张为 [4,32,8] 默认每一个班级的每个学生都适合于这个配置</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>memory consumption</p>
<p>运行时的优化手段，节省内存/显存空间</p>
</li>
<li><p>efficient and intuitive</p>
<ul>
<li>[4,32,32,3]</li>
<li>+ [3]</li>
<li>+ [32,32,1]</li>
<li>+ [4,1,1,1]</li>
</ul>
</li>
</ul>
<h4 id="Broadcastable"><a href="#Broadcastable" class="headerlink" title="Broadcastable?"></a>Broadcastable?</h4><p>是否都能 broadcast ?</p>
<ul>
<li>Match from <font color="red">Last</font> dim!<ul>
<li>if current dim=1, expand to same</li>
<li>if either has no dim, insert one dim and expand to same</li>
<li>otherwise, NOT broadcastable</li>
</ul>
</li>
</ul>
<p>右边对齐，如果相应位置上没有维度，则插入 shape 为1的维度，如果有维度，比较维度是否相等，不等则不行！</p>
<ul>
<li>Examples: ( base [4,32,14,14] )<ul>
<li>[1, 32, 1, 1]<ul>
<li>维度相等，dim=1 的维度可以扩张</li>
</ul>
</li>
<li>[14, 14]<ul>
<li>维度不等，低纬度一致，可以增加维度并扩张</li>
</ul>
</li>
<li>[<font color="red">2</font>, 32, 14, 14]  （×）<ul>
<li>维度相等，但最高维 都不是 1，不能复制！</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>理解：大小维度的概念，小维度给定数字，所有的大维度都是通用的，所有的 dim=1 的维度 默认配置对 所有个例适用</p>
</blockquote>
<h4 id="Broadcasting-1"><a href="#Broadcasting-1" class="headerlink" title="Broadcasting"></a>Broadcasting</h4><p>tf.broadcast_to 可以搞成相同的 shape，实际上这是一种最优化手段，只要操作符支持 broadcast, 就会自动判定shape不一致时，能否 broadcast 为相同的shape</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = tf.random.normal([<span class="number">4</span>,<span class="number">32</span>,<span class="number">32</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment"># tf.broadcast_to 无须调用 即可完成运算</span></span><br><span class="line">(x + tf.random.normal([<span class="number">3</span>])).shape <span class="comment"># TensorShape([4, 32, 32, 3])</span></span><br><span class="line">(x + tf.random.normal([<span class="number">32</span>,<span class="number">32</span>,<span class="number">1</span>])).shape <span class="comment"># TensorShape([4, 32, 32, 3])</span></span><br><span class="line">(x + tf.random.normal([<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])).shape <span class="comment"># TensorShape([4, 32, 32, 3])</span></span><br><span class="line"><span class="comment"># 也可以显式调用</span></span><br><span class="line">b = tf.broadcast_to(tf.random.normal([<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]), [<span class="number">4</span>,<span class="number">32</span>,<span class="number">32</span>,<span class="number">3</span>])</span><br><span class="line">b.shape <span class="comment"># TensorShape([4, 32, 32, 3])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不能完成的</span></span><br><span class="line">(x + tf.random.normal([<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>])).shape</span><br><span class="line"><span class="comment"># tensorflow.python.framework.errors_impl.InvalidArgumentError: Incompatible shapes: [4,32,32,3] vs. [1,4,1,1] [Op:AddV2] name: add/</span></span><br><span class="line"></span><br><span class="line">c = tf.broadcast_to(tf.random.normal([<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]), [<span class="number">3</span>,<span class="number">32</span>,<span class="number">32</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment"># tensorflow.python.framework.errors_impl.InvalidArgumentError: Incompatible shapes: [4,1,1,1] vs. [3,32,32,3] [Op:BroadcastTo]</span></span><br></pre></td></tr></table></figure>
<h4 id="Broadcast-VS-Tile"><a href="#Broadcast-VS-Tile" class="headerlink" title="Broadcast VS Tile"></a>Broadcast VS Tile</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.ones([<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">a1 = tf.broadcast_to(a, [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Tensor: id=4, shape=(2, 3, 4), dtype=float32, numpy=</span></span><br><span class="line"><span class="string">array([[[1., 1., 1., 1.],</span></span><br><span class="line"><span class="string">        [1., 1., 1., 1.],</span></span><br><span class="line"><span class="string">        [1., 1., 1., 1.]],</span></span><br><span class="line"><span class="string">       [[1., 1., 1., 1.],</span></span><br><span class="line"><span class="string">        [1., 1., 1., 1.],</span></span><br><span class="line"><span class="string">        [1., 1., 1., 1.]]], dtype=float32)&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">a2 = tf.expand_dims(a, axis=<span class="number">0</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Tensor: id=6, shape=(1, 3, 4), dtype=float32, numpy=</span></span><br><span class="line"><span class="string">array([[[1., 1., 1., 1.],</span></span><br><span class="line"><span class="string">        [1., 1., 1., 1.],</span></span><br><span class="line"><span class="string">        [1., 1., 1., 1.]]], dtype=float32)&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">a2 = tf.tile(a2, [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Tensor: id=8, shape=(2, 3, 4), dtype=float32, numpy=</span></span><br><span class="line"><span class="string">array([[[1., 1., 1., 1.],</span></span><br><span class="line"><span class="string">        [1., 1., 1., 1.],</span></span><br><span class="line"><span class="string">        [1., 1., 1., 1.]],</span></span><br><span class="line"><span class="string">       [[1., 1., 1., 1.],</span></span><br><span class="line"><span class="string">        [1., 1., 1., 1.],</span></span><br><span class="line"><span class="string">        [1., 1., 1., 1.]]], dtype=float32)&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># a1和a2 功能完全等价, a2 占用内存空间更大</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>索引与切片、维度变换、Broadcast 是 TensorFlow 三大核心操作。掌握后看一些复杂的神经网络结构、复杂的算法变换时，将会对这些操作背后具体的含义理解起来更加轻松</p>
</blockquote>
<h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><blockquote>
<p>description :</p>
<ul>
<li>+-*/</li>
<li>**, pow, square</li>
<li>sqrt</li>
<li>//, %</li>
<li>exp, log</li>
<li>@, matmul</li>
<li>linear, layer</li>
</ul>
</blockquote>
<h4 id="Operation-type"><a href="#Operation-type" class="headerlink" title="Operation type"></a>Operation type</h4><ul>
<li><p>element-wise</p>
<p>+-*/</p>
<p>对应元素的加减乘除</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = tf.fill([<span class="number">2</span>,<span class="number">2</span>],<span class="number">2.</span>)</span><br><span class="line">a = tf.ones([<span class="number">2</span>,<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">a+b</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Tensor: id=6, shape=(2, 2), dtype=float32, numpy=</span></span><br><span class="line"><span class="string">array([[3., 3.],</span></span><br><span class="line"><span class="string">       [3., 3.]], dtype=float32)&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">a-b <span class="comment"># -1</span></span><br><span class="line">a/b <span class="comment"># 0.5</span></span><br><span class="line">b//a <span class="comment"># 2.</span></span><br><span class="line">b%a <span class="comment"># 0.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数，无 tf.log API</span></span><br><span class="line">tf.math.log(a) <span class="comment"># 0.</span></span><br><span class="line"><span class="comment"># 指数</span></span><br><span class="line">tf.math.exp(a) <span class="comment"># 2.7182817</span></span><br><span class="line">tf.exp(a) <span class="comment"># 2.7182817</span></span><br><span class="line"><span class="comment"># log 2, log10 用换底公式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># n次方</span></span><br><span class="line">tf.math.pow(b,<span class="number">3</span>) <span class="comment"># 8.</span></span><br><span class="line">tf.pow(b,<span class="number">3</span>) <span class="comment"># 8.</span></span><br><span class="line">b**<span class="number">3</span> <span class="comment"># 8.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开方</span></span><br><span class="line">tf.sqrt(b) <span class="comment"># 1.4142135</span></span><br><span class="line">tf.math.sqrt(b)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>matrix-wise</p>
<ul>
<li>@</li>
<li>matmul</li>
</ul>
<p>矩阵运算多个并行计算过程：[b,3,4] @ [b,4,5]  =&gt; [b,3,5]</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.fill([<span class="number">2</span>,<span class="number">2</span>],<span class="number">2</span>)</span><br><span class="line">b = tf.fill([<span class="number">2</span>,<span class="number">2</span>],<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 矩阵相乘1</span></span><br><span class="line">a@b</span><br><span class="line">tf.matmul(a,b)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Tensor: id=6, shape=(2, 2), dtype=int32, numpy=</span></span><br><span class="line"><span class="string">array([[12, 12],</span></span><br><span class="line"><span class="string">       [12, 12]])&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = tf.ones([<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">b = tf.fill([<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>],<span class="number">2.</span>)</span><br><span class="line"><span class="comment"># 矩阵相乘2</span></span><br><span class="line"><span class="comment"># [b,c,d] @ [d,f] = [b,c,f]</span></span><br><span class="line">a@b</span><br><span class="line">tf.matmul(a,b) <span class="comment"># TensorShape([4, 2, 5])  6.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">tensorflow/stream_executor/platform/default/dso_loader.cc:44] Successfully opened dynamic library cublas64_100.dll</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵相乘3 —— with broadcastint</span></span><br><span class="line">a = tf.ones([<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">b = tf.fill([<span class="number">3</span>,<span class="number">5</span>],<span class="number">2.</span>)</span><br><span class="line">bb = tf.broadcast_to(b, [<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>])</span><br><span class="line">a@bb <span class="comment"># TensorShape([4, 2, 5])  6.</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Recap</p>
<ul>
<li><p>$y=w*x+b$</p>
</li>
<li><p>$Y=X@W+b$</p>
</li>
<li><script type="math/tex; mode=display">
\left[
\begin{matrix}
\color{red}{x_0^0} & \color{red}{x_0^1}\\
x_1^0 & x_1^1
\end{matrix}
\right]

\left[
\begin{matrix}
w_{00} & w_{01} & w_{02} \\
w_{10} & w_{11} & w_{12}
\end{matrix}
\right]
+
\left[
\begin{matrix}
b_0,b_1,b_2
\end{matrix}
\right]
\rightarrow
\left[
\begin{matrix}
\color{red}{y_0^0} & \color{red}{y_0^1} & \color{red}{y_0^2}\\
y_1^0 & y_1^1 & y_1^2
\end{matrix}
\right]</script></li>
<li><p>$[b,2]\rightarrow[b,3]$</p>
</li>
</ul>
<p>写出矩阵形式好处：写出什么样的矩阵形式，完全取决于之前的运算逻辑。即：标量b 的形式决定了 矩阵的形式，因为矩阵的运算已经规定好，因此元素的位置需要精心的设计使得当前元素的位置在矩阵相乘的操作下满足标量形式的运算规则。也就是说，矩阵只是一个格式，希望通过这样的格式达到目的，目的即为标量形式。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = tf.ones([<span class="number">4</span>,<span class="number">2</span>])</span><br><span class="line">W = tf.ones([<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line">b = tf.constant(<span class="number">0.1</span>)</span><br><span class="line">out = x@W+b</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Tensor: id=33, shape=(4, 1), dtype=float32, numpy=</span></span><br><span class="line"><span class="string">array([[2.1],</span></span><br><span class="line"><span class="string">       [2.1],</span></span><br><span class="line"><span class="string">       [2.1],</span></span><br><span class="line"><span class="string">       [2.1]], dtype=float32)&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 加入非线性因子</span></span><br><span class="line">out = tf.nn.relu(out)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Tensor: id=36, shape=(4, 1), dtype=float32, numpy=</span></span><br><span class="line"><span class="string">array([[2.1],</span></span><br><span class="line"><span class="string">       [2.1],</span></span><br><span class="line"><span class="string">       [2.1],</span></span><br><span class="line"><span class="string">       [2.1]], dtype=float32)&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>dim-wise</p>
<ul>
<li>reduce_mean</li>
<li>max</li>
<li>min</li>
<li>sum</li>
</ul>
<p>对某个维度进行操作</p>
</li>
</ul>
<h3 id="前向传播（张量）-实战"><a href="#前向传播（张量）-实战" class="headerlink" title="前向传播（张量）-实战"></a>前向传播（张量）-实战</h3><p>基本技巧：创建 Tensor，读取Tensor部分数据，Tensor维度变换，对Tensor进行数学运算，后续还会介绍高阶技巧。</p>
<h4 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h4><ul>
<li>串联 多个简单非线性层 $relu[X@W_1+b_1]$ 增加复杂度，得到输出</li>
<li>$pred=argmax(out)$</li>
<li>$loss=MSE(out, label)$</li>
<li>minimize $loss$</li>
</ul>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>有最底层的 方式——张量直接作矩阵运算实现前向传播，后续讲解如何使用 层方式。从0开始，每个细节都掌控到，对dp理解才深刻。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>] = <span class="string">'2'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># x: [60k, 28, 28],</span></span><br><span class="line"><span class="comment"># y: [60k]</span></span><br><span class="line">(x, y), _ = datasets.mnist.load_data()</span><br><span class="line"><span class="comment"># x: [0~255] =&gt; [0~1.]</span></span><br><span class="line">x = tf.convert_to_tensor(x, dtype=tf.float32) / <span class="number">255.</span></span><br><span class="line">y = tf.convert_to_tensor(y, dtype=tf.int32)</span><br><span class="line"></span><br><span class="line">print(x.shape, y.shape, x.dtype, y.dtype)</span><br><span class="line">print(tf.reduce_min(x), tf.reduce_max(x))</span><br><span class="line">print(tf.reduce_min(y), tf.reduce_max(y))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train_db = tf.data.Dataset.from_tensor_slices((x,y)).batch(<span class="number">128</span>)</span><br><span class="line">train_iter = iter(train_db)</span><br><span class="line">sample = next(train_iter)</span><br><span class="line"><span class="comment"># 一批 128个数据</span></span><br><span class="line">print(<span class="string">'batch:'</span>, sample[<span class="number">0</span>].shape, sample[<span class="number">1</span>].shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中间的数值随便定</span></span><br><span class="line"><span class="comment"># [b, 784] =&gt; [b, 256] =&gt; [b, 128] =&gt; [b, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># w shape 需要满足矩阵运算规则 [dim_in, dim_out]</span></span><br><span class="line"><span class="comment"># b shape 满足： [dim_out]</span></span><br><span class="line">w1 = tf.Variable(tf.random.truncated_normal([<span class="number">784</span>, <span class="number">256</span>], stddev=<span class="number">0.1</span>)) <span class="comment"># 方差变小，预防梯度爆炸</span></span><br><span class="line">b1 = tf.Variable(tf.zeros([<span class="number">256</span>]))</span><br><span class="line">w2 = tf.Variable(tf.random.truncated_normal([<span class="number">256</span>, <span class="number">128</span>], stddev=<span class="number">0.1</span>))</span><br><span class="line">b2 = tf.Variable(tf.zeros([<span class="number">128</span>]))</span><br><span class="line">w3 = tf.Variable(tf.random.truncated_normal([<span class="number">128</span>, <span class="number">10</span>], stddev=<span class="number">0.1</span>))</span><br><span class="line">b3 = tf.Variable(tf.zeros([<span class="number">10</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># learn rate</span></span><br><span class="line">lr = <span class="number">1e-3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">10</span>): <span class="comment"># iterate db for 10</span></span><br><span class="line">    <span class="keyword">for</span> step, (x, y) <span class="keyword">in</span> enumerate(train_db): <span class="comment"># for every batch</span></span><br><span class="line">        <span class="comment"># x:[128, 28, 28]</span></span><br><span class="line">        <span class="comment"># y: [128]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># [b, 28, 28] =&gt; [b, 28*28]</span></span><br><span class="line">        x = tf.reshape(x, [<span class="number">-1</span>, <span class="number">28</span>*<span class="number">28</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 自动求导过程，只会跟踪tf.Variable</span></span><br><span class="line">        <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape: <span class="comment"># tf.Variable</span></span><br><span class="line">            <span class="comment"># x: [b, 28*28]</span></span><br><span class="line">            <span class="comment"># h1 = x@w1 + b1</span></span><br><span class="line">            <span class="comment"># [b, 784]@[784, 256] + [256] =&gt; [b, 256] + [256] =&gt; [b, 256] + [b, 256]</span></span><br><span class="line">            h1 = x@w1 + tf.broadcast_to(b1, [x.shape[<span class="number">0</span>], <span class="number">256</span>])</span><br><span class="line">            h1 = tf.nn.relu(h1)</span><br><span class="line">            <span class="comment"># [b, 256] =&gt; [b, 128]</span></span><br><span class="line">            h2 = h1@w2 + b2</span><br><span class="line">            h2 = tf.nn.relu(h2)</span><br><span class="line">            <span class="comment"># [b, 128] =&gt; [b, 10]</span></span><br><span class="line">            out = h2@w3 + b3</span><br><span class="line"></span><br><span class="line">            <span class="comment"># compute loss</span></span><br><span class="line">            <span class="comment"># out: [b, 10]</span></span><br><span class="line">            <span class="comment"># y: [b] =&gt; [b, 10]</span></span><br><span class="line">            y_onehot = tf.one_hot(y, depth=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># mse = mean(sum(y-out)^2)</span></span><br><span class="line">            <span class="comment"># [b, 10]</span></span><br><span class="line">            loss = tf.square(y_onehot - out)</span><br><span class="line">            <span class="comment"># mean: scalar</span></span><br><span class="line">            loss = tf.reduce_mean(loss)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># compute gradients</span></span><br><span class="line">        grads = tape.gradient(loss, [w1, b1, w2, b2, w3, b3])</span><br><span class="line">        <span class="comment"># print(grads)</span></span><br><span class="line">        <span class="comment"># w1 = w1 - lr * w1_grad[0]</span></span><br><span class="line">        <span class="comment"># 这种情况下w1更新后 是一个新的对象，失去 tf.Variable 属性</span></span><br><span class="line">        <span class="comment"># 需要原地更新，即引用不变！</span></span><br><span class="line">        w1.assign_sub(lr * grads[<span class="number">0</span>])</span><br><span class="line">        b1.assign_sub(lr * grads[<span class="number">1</span>])</span><br><span class="line">        w2.assign_sub(lr * grads[<span class="number">2</span>])</span><br><span class="line">        b2.assign_sub(lr * grads[<span class="number">3</span>])</span><br><span class="line">        w3.assign_sub(lr * grads[<span class="number">4</span>])</span><br><span class="line">        b3.assign_sub(lr * grads[<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> step % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            print(epoch, step, <span class="string">'loss:'</span>, float(loss))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">loss:nan 解决：</span></span><br><span class="line"><span class="string">这是 梯度爆炸 情况，这里不讲如何解决问题，牵扯内容过多，这里只给出解决方案：</span></span><br><span class="line"><span class="string">初始化的时候给一个比较好的范围</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">迭代：</span></span><br><span class="line"><span class="string">第一层：迭代数据集 10次，迭代第二次的时候已经很好，继续迭代loss在不断下降——意味着训练能达到很好的收敛状态</span></span><br><span class="line"><span class="string">    甚至迭代数百次、数千次都可以。只不过数据集总量不变，循环次数增加罢了，最终状态（天花板）是一定的</span></span><br><span class="line"><span class="string">第二层：迭代batch</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p>完成了比较复杂的 三层前向传播及优化过程。</p>
<h2 id="TensorFlow-2-高阶操作"><a href="#TensorFlow-2-高阶操作" class="headerlink" title="TensorFlow 2 高阶操作"></a>TensorFlow 2 高阶操作</h2><h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><h4 id="tf-concat-拼接"><a href="#tf-concat-拼接" class="headerlink" title="tf.concat | 拼接"></a>tf.concat | 拼接</h4><ul>
<li>需要指定在哪个维度上进行合并</li>
<li>不会增加维度，因为是在原有维度上进行累加</li>
<li>所要拼接的维度可以不等，其他维度必须相等！</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># axis = 0</span></span><br><span class="line">a = tf.ones([<span class="number">4</span>,<span class="number">35</span>,<span class="number">8</span>])</span><br><span class="line">b = tf.ones([<span class="number">2</span>,<span class="number">35</span>,<span class="number">8</span>])</span><br><span class="line">c = tf.concat([a,b],axis=<span class="number">0</span>) <span class="comment"># TensorShape([6, 35, 8])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># axis = 1</span></span><br><span class="line">a = tf.ones([<span class="number">4</span>,<span class="number">32</span>,<span class="number">8</span>])</span><br><span class="line">b = tf.ones([<span class="number">4</span>,<span class="number">3</span>,<span class="number">8</span>])</span><br><span class="line">c = tf.concat([a,b],axis=<span class="number">1</span>) <span class="comment"># TensorShape([4, 35, 8])</span></span><br></pre></td></tr></table></figure>
<h4 id="tf-stack-堆叠"><a href="#tf-stack-堆叠" class="headerlink" title="tf.stack | 堆叠"></a>tf.stack | 堆叠</h4><ul>
<li>会创建新的维度</li>
<li>要求 Tensor 所有维度相等！</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a和b来自两个 school</span></span><br><span class="line">a = tf.ones([<span class="number">4</span>,<span class="number">35</span>,<span class="number">8</span>])</span><br><span class="line">b = tf.ones([<span class="number">4</span>,<span class="number">35</span>,<span class="number">8</span>])</span><br><span class="line"><span class="comment"># concat 不会增加维度</span></span><br><span class="line">tf.concat([a,b], axis=<span class="number">-1</span>).shape <span class="comment"># TensorShape([4, 35, 16])</span></span><br><span class="line">tf.concat([a,b], axis=<span class="number">1</span>).shape <span class="comment"># TensorShape([4, 70, 8])</span></span><br><span class="line"><span class="comment"># stack创造新的维度</span></span><br><span class="line">d1 = tf.stack([a,b], axis=<span class="number">0</span>) <span class="comment"># TensorShape([2, 4, 35, 8])</span></span><br><span class="line">d2 = tf.stack([a,b],axis=<span class="number">3</span>) <span class="comment"># TensorShape([4, 35, 8, 2])</span></span><br><span class="line"><span class="comment"># axis=3时，在"8"这个概念下，再划分一个维度，分a和b两个school，也可以理解，但没有=0(大维度放前)容易理解</span></span><br></pre></td></tr></table></figure>
<p>一些维度不一致的错误</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.ones([<span class="number">4</span>,<span class="number">35</span>,<span class="number">8</span>])</span><br><span class="line">b = tf.ones([<span class="number">3</span>,<span class="number">33</span>,<span class="number">8</span>])</span><br><span class="line">tf.concat([a,b],axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># tensorflow.python.framework.errors_impl.InvalidArgumentError: ConcatOp : Dimensions of inputs should match: shape[0] = [4,35,8] vs. shape[1] = [3,33,8] [Op:ConcatV2] name: concat</span></span><br><span class="line"></span><br><span class="line">b = tf.ones([<span class="number">2</span>,<span class="number">35</span>,<span class="number">8</span>])</span><br><span class="line">c = tf.concat([a,b], axis=<span class="number">0</span>) <span class="comment"># TensorShape([6, 35, 8])</span></span><br><span class="line">tf.stack([a,b], axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># tensorflow.python.framework.errors_impl.InvalidArgumentError: Shapes of all inputs must match: values[0].shape = [4,35,8] != values[1].shape = [2,35,8] [Op:Pack] name: stack</span></span><br></pre></td></tr></table></figure>
<h3 id="Split"><a href="#Split" class="headerlink" title="Split"></a>Split</h3><ul>
<li>tf.split<ul>
<li>打散方式更灵活</li>
</ul>
</li>
<li>tf.unstack<ul>
<li>特性：指定axis全部打散为1，该维度消失</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.ones([<span class="number">4</span>,<span class="number">35</span>,<span class="number">8</span>])</span><br><span class="line">b = tf.ones([<span class="number">4</span>,<span class="number">35</span>,<span class="number">8</span>])</span><br><span class="line">c = tf.stack([a,b]) <span class="comment"># TensorShape([2, 4, 35, 8])</span></span><br><span class="line">aa, bb = tf.unstack(c, axis=<span class="number">0</span>) <span class="comment"># list</span></span><br><span class="line">aa.shape, bb.shape <span class="comment"># TensorShape([4, 35, 8])</span></span><br><span class="line"></span><br><span class="line">c.shape <span class="comment"># TensorShape([2, 4, 35, 8])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将"8"这个维度打散</span></span><br><span class="line">res = tf.unstack(c, axis=<span class="number">3</span>) <span class="comment"># len: 8</span></span><br><span class="line">res[<span class="number">0</span>].shape <span class="comment"># TensorShape([2, 4, 35])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将"8"这个维度分割成2份</span></span><br><span class="line">res = tf.split(c, num_or_size_splits=<span class="number">2</span>, axis=<span class="number">3</span>) <span class="comment"># len: 2</span></span><br><span class="line">res[<span class="number">0</span>].shape <span class="comment"># TensorShape([2, 4, 35, 4])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将"8"这个维度按照指定的长度打散</span></span><br><span class="line">res = tf.split(c, num_or_size_splits=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">-1</span>], axis=<span class="number">3</span>)</span><br><span class="line">res[<span class="number">0</span>].shape <span class="comment"># TensorShape([2, 4, 35, 2])</span></span><br><span class="line">res[<span class="number">1</span>].shape <span class="comment"># TensorShape([2, 4, 35, 3])</span></span><br><span class="line">res[<span class="number">2</span>].shape <span class="comment"># TensorShape([2, 4, 35, 3])</span></span><br></pre></td></tr></table></figure>
<h3 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h3><h4 id="tf-norm"><a href="#tf-norm" class="headerlink" title="tf.norm"></a>tf.norm</h4><p>向量范数</p>
<script type="math/tex; mode=display">
\bold{Eukl.\ Norm}\quad\left\|x\right\|_2=[\sum_k x_k^2]^{\frac{1}{2}} \\
\bold{Max.norm}\quad \left\|x\right\|_\infty=\max_k|x_k| \\
\bold{L_1-Norm}\quad \left\|x\right\|_1=\sum_k|x_k|</script><h5 id="二范数-tf-norm-x"><a href="#二范数-tf-norm-x" class="headerlink" title="二范数 tf.norm(x)"></a>二范数 tf.norm(x)</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.constant([[<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]], dtype=tf.float32)</span><br><span class="line"><span class="comment"># sqrt(45)</span></span><br><span class="line">tf.norm(a) <span class="comment"># &lt;tf.Tensor: id=12, shape=(), dtype=float32, numpy=6.708204&gt;</span></span><br><span class="line">tf.sqrt(tf.reduce_sum(tf.square(a))) <span class="comment"># 同上</span></span><br><span class="line"></span><br><span class="line">b = tf.ones([<span class="number">4</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">3</span>])</span><br><span class="line">tf.norm(b) <span class="comment"># 96.99484</span></span><br><span class="line">tf.sqrt(tf.reduce_sum(tf.square(b))) <span class="comment"># 96.99484</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定axis</span></span><br><span class="line">tf.norm(a, ord=<span class="number">2</span>, axis=<span class="number">1</span>) <span class="comment">#[sqrt(30.),sqrt(15.)]</span></span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=34, shape=(2,), dtype=float32, numpy=array([5.477226 , 3.8729835], dtype=float32)&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="L1-Norm"><a href="#L1-Norm" class="headerlink" title="L1 Norm"></a>L1 Norm</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ord=1</span></span><br><span class="line">a = tf.constant([[<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]], dtype=tf.float32) <span class="comment"># TensorShape([2, 4])</span></span><br><span class="line">tf.norm(a, ord=<span class="number">1</span>) <span class="comment"># 17.0</span></span><br><span class="line">tf.norm(a, ord=<span class="number">1</span>, axis=<span class="number">0</span>) <span class="comment"># [5., 2., 5., 5.]</span></span><br><span class="line">tf.norm(a, ord=<span class="number">1</span>, axis=<span class="number">1</span>) <span class="comment"># [10.,  7.]</span></span><br></pre></td></tr></table></figure>
<p>矩阵范数不讨论……</p>
<h4 id="tf-reduce-min-max-mean"><a href="#tf-reduce-min-max-mean" class="headerlink" title="tf.reduce_min/max/mean"></a>tf.reduce_min/max/mean</h4><p>最值、平均值，reduce是提醒 该过程会降维</p>
<ul>
<li>axis 指定后，会在该参数轴上求最值，同时该轴的维度消失…</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.constant([[<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]], dtype=tf.float32) <span class="comment"># TensorShape([2, 4])</span></span><br><span class="line"><span class="comment"># 不指定axis 结果为 scatter</span></span><br><span class="line">tf.reduce_max(a) <span class="comment"># 4.0</span></span><br><span class="line">tf.reduce_min(a) <span class="comment"># 1.0</span></span><br><span class="line">tf.reduce_mean(a) <span class="comment"># 2.125</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># axis=0 ==&gt; TensorShape([4])</span></span><br><span class="line">tf.reduce_max(a, axis=<span class="number">0</span>) <span class="comment"># [4., 1., 3., 3.]</span></span><br><span class="line">tf.reduce_min(a, axis=<span class="number">0</span>) <span class="comment"># [1., 1., 2., 2.]</span></span><br><span class="line">tf.reduce_mean(a, axis=<span class="number">0</span>) <span class="comment"># [2.5, 1. , 2.5, 2.5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># axis=1 ==&gt; TensorShape([2])</span></span><br><span class="line">tf.reduce_max(a, axis=<span class="number">1</span>) <span class="comment"># [4., 3.]</span></span><br><span class="line">tf.reduce_min(a, axis=<span class="number">1</span>) <span class="comment"># [1., 1.]</span></span><br><span class="line">tf.reduce_mean(a, axis=<span class="number">1</span>) <span class="comment"># [2.5 , 1.75]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># axis=2 ==&gt; InvalidArgumentError: Invalid reduction dimension (2 for input with 2 dimension(s) [Op:Mean]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.random.uniform([<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],dtype=tf.int32,maxval=<span class="number">10</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[[6, 4, 3, 6, 7],</span></span><br><span class="line"><span class="string">        [8, 7, 0, 2, 2],</span></span><br><span class="line"><span class="string">        [0, 7, 3, 7, 7],</span></span><br><span class="line"><span class="string">        [4, 5, 4, 9, 6]],</span></span><br><span class="line"><span class="string">       [[7, 4, 5, 1, 7],</span></span><br><span class="line"><span class="string">        [4, 8, 7, 6, 1],</span></span><br><span class="line"><span class="string">        [3, 6, 5, 0, 5],</span></span><br><span class="line"><span class="string">        [1, 0, 8, 7, 7]],</span></span><br><span class="line"><span class="string">       [[1, 2, 3, 9, 4],</span></span><br><span class="line"><span class="string">        [0, 8, 6, 4, 0],</span></span><br><span class="line"><span class="string">        [4, 6, 2, 9, 2],</span></span><br><span class="line"><span class="string">        [4, 5, 7, 2, 0]]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">tf.reduce_max(a) <span class="comment"># 9</span></span><br><span class="line">tf.reduce_max(a, axis=<span class="number">0</span>) <span class="comment"># TensorShape([4, 5])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[[7, 4, 5, 9, 7],</span></span><br><span class="line"><span class="string"> [8, 8, 7, 6, 2],</span></span><br><span class="line"><span class="string"> [4, 7, 5, 9, 7],</span></span><br><span class="line"><span class="string"> [4, 5, 8, 9, 7]]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">tf.reduce_max(a, axis=<span class="number">1</span>) <span class="comment"># TensorShape([3, 5])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[[8, 7, 4, 9, 7],</span></span><br><span class="line"><span class="string"> [7, 8, 8, 7, 7],</span></span><br><span class="line"><span class="string"> [4, 8, 7, 9, 4]]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">tf.reduce_max(a, axis=<span class="number">2</span>) <span class="comment"># TensorShape([3, 4])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[[7, 8, 7, 9],</span></span><br><span class="line"><span class="string"> [7, 8, 6, 8],</span></span><br><span class="line"><span class="string"> [9, 8, 9, 7]]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p>理解：将shape写出来后，axis 所在的那个维度，进行操作后维度消失。</p>
<h4 id="tf-argmax-argmin"><a href="#tf-argmax-argmin" class="headerlink" title="tf.argmax/argmin"></a>tf.argmax/argmin</h4><p>最值位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.shape <span class="comment"># TensorShape([3, 4, 5])</span></span><br><span class="line">tf.argmax(a) <span class="comment"># TensorShape([4, 5])</span></span><br><span class="line">tf.argmax(a,axis=<span class="number">0</span>) <span class="comment"># 默认axis=0</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[[1, 0, 1, 2, 0],</span></span><br><span class="line"><span class="string"> [0, 1, 1, 1, 0],</span></span><br><span class="line"><span class="string"> [2, 0, 1, 2, 0],</span></span><br><span class="line"><span class="string"> [0, 0, 1, 0, 1]]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">tf.argmax(a,axis=<span class="number">1</span>) <span class="comment"># TensorShape([3, 5])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[[1, 1, 3, 3, 0],</span></span><br><span class="line"><span class="string"> [0, 1, 3, 3, 0],</span></span><br><span class="line"><span class="string"> [2, 1, 3, 0, 0]],</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">tf.argmax(a,axis=<span class="number">2</span>) <span class="comment"># TensorShape([3, 4])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[[4, 0, 1, 3],</span></span><br><span class="line"><span class="string"> [0, 1, 1, 2],</span></span><br><span class="line"><span class="string"> [3, 1, 3, 2]]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h4 id="tf-equal"><a href="#tf-equal" class="headerlink" title="tf.equal"></a>tf.equal</h4><p>比较</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.constant([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>])</span><br><span class="line">b = tf.range(<span class="number">5</span>)</span><br><span class="line">res = tf.equal(a,b)</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=5, shape=(5,), dtype=bool, numpy=array([False, False, False, False, False])&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算相同结果数目，可以得到 准确度</span></span><br><span class="line">tf.reduce_sum(tf.cast(res, dtype=tf.int32)) <span class="comment"># 0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Accuracy</span></span><br><span class="line"><span class="comment"># shape: [2,3] 表示2个样本预测 每个输出 的概率</span></span><br><span class="line">a = tf.constant([[<span class="number">0.1</span>,<span class="number">0.2</span>,<span class="number">0.7</span>],</span><br><span class="line">                 [<span class="number">0.9</span>,<span class="number">0.05</span>,<span class="number">0.05</span>]])</span><br><span class="line"><span class="comment"># 根据概率求预测值，即将概率最大的作为预测值</span></span><br><span class="line">pred = tf.cast(tf.argmax(a, axis=<span class="number">1</span>), dtype=tf.int32)</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=14, shape=(2,), dtype=int32, numpy=array([2, 0])&gt;</span></span><br><span class="line"></span><br><span class="line">y = tf.constant([<span class="number">2</span>,<span class="number">1</span>], dtype=tf.int32)</span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=17, shape=(2,), dtype=int32, numpy=array([2, 1])&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测正确的个数</span></span><br><span class="line">correct = tf.reduce_sum(tf.cast(tf.equal(y,pred), dtype=tf.int32)) <span class="comment"># 1</span></span><br><span class="line">accuracy = correct / <span class="number">2</span></span><br><span class="line"><span class="comment"># &lt;tf.Tensor: id=25, shape=(), dtype=float64, numpy=0.5&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="tf-unique"><a href="#tf-unique" class="headerlink" title="tf.unique"></a>tf.unique</h4><p>去除重复值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.constant([<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>])</span><br><span class="line">tf.unique(a)</span><br><span class="line"><span class="comment"># Unique(y=&lt;tf.Tensor: id=1, shape=(3,), dtype=int32, numpy=array([4, 2, 3])&gt;, idx=&lt;tf.Tensor: id=2, shape=(5,), dtype=int32, numpy=array([0, 1, 1, 0, 2])&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还原</span></span><br><span class="line">aa = tf.gather(d.y, d.idx)</span><br></pre></td></tr></table></figure>
<h3 id="张量排序"><a href="#张量排序" class="headerlink" title="张量排序"></a>张量排序</h3><h4 id="Sort-argsort"><a href="#Sort-argsort" class="headerlink" title="Sort/argsort"></a>Sort/argsort</h4><p>默认 axis = -1</p>
<ul>
<li>sort: 完全排序：对一个序列完整的排序</li>
<li>argsort: 返回 大小顺序的 idx</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.random.shuffle(tf.range(<span class="number">5</span>)) <span class="comment"># [3, 1, 2, 0, 4]</span></span><br><span class="line">tf.sort(a, direction=<span class="string">"DESCENDING"</span>) <span class="comment"># [4, 3, 2, 1, 0]</span></span><br><span class="line">tf.sort(a) <span class="comment"># [0, 1, 2, 3, 4] 默认ASCENDING</span></span><br><span class="line"></span><br><span class="line">idx = tf.argsort(a, direction=<span class="string">"DESCENDING"</span>) <span class="comment"># [4, 0, 2, 1, 3]</span></span><br><span class="line">tf.argsort(a) <span class="comment"># [3, 1, 2, 0, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得idx后有 gather 还原</span></span><br><span class="line">tf.gather(a, idx) <span class="comment"># [4, 3, 2, 1, 0]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.random.uniform([<span class="number">3</span>,<span class="number">3</span>], maxval=<span class="number">10</span>, dtype=tf.int32)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[1, 5, 2],</span></span><br><span class="line"><span class="string">       [3, 2, 9],</span></span><br><span class="line"><span class="string">       [2, 8, 2]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">tf.sort(a)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[1, 2, 5],</span></span><br><span class="line"><span class="string">       [2, 3, 9],</span></span><br><span class="line"><span class="string">       [2, 2, 8]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">idx = tf.argsort(a)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[0, 2, 1],</span></span><br><span class="line"><span class="string">       [1, 0, 2],</span></span><br><span class="line"><span class="string">       [0, 2, 1]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h4 id="TopK"><a href="#TopK" class="headerlink" title="TopK"></a>TopK</h4><p>如果对 Tensor全部进行排序，可能会耗费很长时间。有时候仅需要取前几个值</p>
<p>API: <span class="exturl" data-url="aHR0cHM6Ly90ZW5zb3JmbG93Lmdvb2dsZS5jbi9hcGlfZG9jcy9weXRob24vdGYvbWF0aC90b3Bfaw==" title="https://tensorflow.google.cn/api_docs/python/tf/math/top_k">https://tensorflow.google.cn/api_docs/python/tf/math/top_k<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = tf.math.top_k(a,<span class="number">2</span>) <span class="comment"># type:tensorflow.python.ops.gen_nn_ops.TopKV2</span></span><br><span class="line">res.indices</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Tensor: id=94, shape=(3, 2), dtype=int32, numpy=</span></span><br><span class="line"><span class="string">array([[1, 2],</span></span><br><span class="line"><span class="string">       [2, 0],</span></span><br><span class="line"><span class="string">       [1, 0]])&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">res.values</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;tf.Tensor: id=93, shape=(3, 2), dtype=int32, numpy=</span></span><br><span class="line"><span class="string">array([[5, 2],</span></span><br><span class="line"><span class="string">       [9, 3],</span></span><br><span class="line"><span class="string">       [8, 2]])&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h4 id="Top-k-Acc"><a href="#Top-k-Acc" class="headerlink" title="Top-k Acc."></a>Top-k Acc.</h4><ul>
<li>Prob: [0.1, 0.2, <font color="red">0.3, 0.4</font>]</li>
<li>Label: [2]</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">consider top k</th>
<th style="text-align:center">prediction</th>
<th style="text-align:center">accuracy</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">[3]</td>
<td style="text-align:center">0/1=0%</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">[3,2]</td>
<td style="text-align:center">100%</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">[3,2,1]</td>
<td style="text-align:center">100%</td>
</tr>
</tbody>
</table>
</div>
<p>保证 前k个 中有一个是对的就说明准确。Top-1 最严格，但表现不是很好，例如 ImageNet 中，Top-1 可能就70%，可以考虑 Top-5，可以作为算法性能指标</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实战：计算Top-k Acc.</span></span><br><span class="line"><span class="comment"># 并假设索引值即为预测值</span></span><br><span class="line">prob = tf.constant([[<span class="number">0.1</span>,<span class="number">0.2</span>,<span class="number">0.7</span>], <span class="comment"># 第一个样本预测结果 2&gt;1&gt;0</span></span><br><span class="line">                    [<span class="number">0.2</span>,<span class="number">0.7</span>,<span class="number">0.1</span>]])<span class="comment"># 第二个样本预测结果 1&gt;0&gt;2</span></span><br><span class="line"></span><br><span class="line">target = tf.constant([<span class="number">2</span>,<span class="number">0</span>]) <span class="comment"># 假设实际的结果分别为 2,0</span></span><br><span class="line"></span><br><span class="line">k_b = tf.math.top_k(prob, <span class="number">3</span>).indices</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[2, 1, 0],</span></span><br><span class="line"><span class="string">       [1, 0, 2]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 转置</span></span><br><span class="line">k_b = tf.transpose(k_b, [<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 第一行是Top1, 第二行是Top2 ……</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[2, 1],</span></span><br><span class="line"><span class="string">       [1, 0],</span></span><br><span class="line"><span class="string">       [0, 2]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">target = tf.broadcast_to(target, [<span class="number">3</span>,<span class="number">2</span>])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[2, 0],</span></span><br><span class="line"><span class="string">       [2, 0],</span></span><br><span class="line"><span class="string">       [2, 0]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p>完整代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span>  os</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>] = <span class="string">'2'</span></span><br><span class="line">tf.random.set_seed(<span class="number">2467</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accuracy</span><span class="params">(output, target, topk=<span class="params">(<span class="number">1</span>,)</span>)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    计算 Top-K准确度</span></span><br><span class="line"><span class="string">    :param output: 预测值</span></span><br><span class="line"><span class="string">    :param target: 真实值</span></span><br><span class="line"><span class="string">    :param topk: 输出的top-k类别，e.g. (1,2)则会输出[top1,top2]</span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    maxk = max(topk)</span><br><span class="line">    <span class="comment"># 样本总数</span></span><br><span class="line">    batch_size = target.shape[<span class="number">0</span>]</span><br><span class="line">	<span class="comment"># 为了跟 target 对应，需要进行转置操作 </span></span><br><span class="line">    pred = tf.math.top_k(output, maxk).indices</span><br><span class="line">    pred = tf.transpose(pred, perm=[<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 为了与pred进行比较来 计算top-k, 需要扩张成 pred 的shape</span></span><br><span class="line">    target_ = tf.broadcast_to(target, pred.shape)</span><br><span class="line">    <span class="comment"># [10, b]</span></span><br><span class="line">    correct = tf.equal(pred, target_)</span><br><span class="line"></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> topk:</span><br><span class="line">        <span class="comment"># Top-n 中仅有一个是对的！</span></span><br><span class="line">        correct_k = tf.cast(tf.reshape(correct[:k], [<span class="number">-1</span>]), dtype=tf.float32)</span><br><span class="line">        <span class="comment"># 累加求和即可得到正确的个数</span></span><br><span class="line">        correct_k = tf.reduce_sum(correct_k)</span><br><span class="line">        acc = float(correct_k* (<span class="number">100.0</span> / batch_size) )</span><br><span class="line">        res.append(acc)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 10个样本，6类</span></span><br><span class="line">output = tf.random.normal([<span class="number">10</span>, <span class="number">6</span>])</span><br><span class="line"><span class="comment"># 使得6类总和为1</span></span><br><span class="line">output = tf.math.softmax(output, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 0-5随机 label作为 target</span></span><br><span class="line">target = tf.random.uniform([<span class="number">10</span>], maxval=<span class="number">6</span>, dtype=tf.int32)</span><br><span class="line">print(<span class="string">'prob:'</span>, output.numpy())</span><br><span class="line">pred = tf.argmax(output, axis=<span class="number">1</span>)</span><br><span class="line">print(<span class="string">'pred:'</span>, pred.numpy())</span><br><span class="line">print(<span class="string">'label:'</span>, target.numpy())</span><br><span class="line"></span><br><span class="line">acc = accuracy(output, target, topk=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line">print(<span class="string">'top-1-6 acc:'</span>, acc)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prob: [[<span class="number">0.25310278</span> <span class="number">0.21715644</span> <span class="number">0.16043882</span> <span class="number">0.13088997</span> <span class="number">0.04334083</span> <span class="number">0.19507109</span>]</span><br><span class="line"> [<span class="number">0.05892418</span> <span class="number">0.04548917</span> <span class="number">0.00926314</span> <span class="number">0.14529602</span> <span class="number">0.66777605</span> <span class="number">0.07325139</span>]</span><br><span class="line"> [<span class="number">0.09742808</span> <span class="number">0.08304427</span> <span class="number">0.07460099</span> <span class="number">0.04067177</span> <span class="number">0.626185</span>   <span class="number">0.07806987</span>]</span><br><span class="line"> [<span class="number">0.20478569</span> <span class="number">0.12294924</span> <span class="number">0.12010485</span> <span class="number">0.13751231</span> <span class="number">0.36418733</span> <span class="number">0.05046057</span>]</span><br><span class="line"> [<span class="number">0.11872064</span> <span class="number">0.31072393</span> <span class="number">0.12530336</span> <span class="number">0.1552888</span>  <span class="number">0.2132587</span>  <span class="number">0.07670452</span>]</span><br><span class="line"> [<span class="number">0.01519807</span> <span class="number">0.09672114</span> <span class="number">0.1460476</span>  <span class="number">0.00934331</span> <span class="number">0.5649092</span>  <span class="number">0.16778067</span>]</span><br><span class="line"> [<span class="number">0.04199061</span> <span class="number">0.18141054</span> <span class="number">0.06647632</span> <span class="number">0.6006175</span>  <span class="number">0.03198383</span> <span class="number">0.07752118</span>]</span><br><span class="line"> [<span class="number">0.09226219</span> <span class="number">0.2346089</span>  <span class="number">0.13022321</span> <span class="number">0.16295874</span> <span class="number">0.05362028</span> <span class="number">0.3263266</span> ]</span><br><span class="line"> [<span class="number">0.07019574</span> <span class="number">0.0861177</span>  <span class="number">0.10912605</span> <span class="number">0.10521299</span> <span class="number">0.2152082</span>  <span class="number">0.4141393</span> ]</span><br><span class="line"> [<span class="number">0.01882887</span> <span class="number">0.26597694</span> <span class="number">0.19122466</span> <span class="number">0.24109262</span> <span class="number">0.14920162</span> <span class="number">0.13367532</span>]]</span><br><span class="line">pred: [<span class="number">0</span> <span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">5</span> <span class="number">5</span> <span class="number">1</span>]</span><br><span class="line">label: [<span class="number">0</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">5</span>]</span><br><span class="line">top<span class="number">-1</span><span class="number">-6</span> acc: [<span class="number">40.0</span>, <span class="number">40.0</span>, <span class="number">50.0</span>, <span class="number">70.0</span>, <span class="number">80.0</span>, <span class="number">100.0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="填充和复制"><a href="#填充和复制" class="headerlink" title="填充和复制"></a>填充和复制</h3><h4 id="pad"><a href="#pad" class="headerlink" title="pad"></a>pad</h4><p>当shape为 [3, 3]，ndim=2 时，paddings参数为填充方式</p>
<p>paddings: [top，bottom], [left, right]</p>
<p>猜测：总共的方括号有 ndim 个，每个ndim表示在该维度上进行填充，里边的元素个数 为 2；就拿本例来说：ndim=2，axis=0 是行的概念，第一个[]就在行的上下进行填充，第二个[] 就在列的左右进行填充</p>
<p>具体事例看API</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.reshape(tf.range(<span class="number">9</span>),[<span class="number">3</span>,<span class="number">-1</span>])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[0, 1, 2],</span></span><br><span class="line"><span class="string">       [3, 4, 5],</span></span><br><span class="line"><span class="string">       [6, 7, 8]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">tf.pad(a, [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[0, 0, 0, 0],</span></span><br><span class="line"><span class="string">       [0, 1, 2, 0],</span></span><br><span class="line"><span class="string">       [3, 4, 5, 0],</span></span><br><span class="line"><span class="string">       [6, 7, 8, 0],</span></span><br><span class="line"><span class="string">       [0, 0, 0, 0]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">tf.pad(a, [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>]])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[0, 0, 0, 0, 0],</span></span><br><span class="line"><span class="string">       [0, 0, 1, 2, 0],</span></span><br><span class="line"><span class="string">       [0, 3, 4, 5, 0],</span></span><br><span class="line"><span class="string">       [0, 6, 7, 8, 0],</span></span><br><span class="line"><span class="string">       [0, 0, 0, 0, 0]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p>Image padding</p>
<ul>
<li>一般情况下，卷积(converlutional)操作得到的size（called B）会略小于原来的size(called A)，把 A padding 为 A’，使得A’ 卷积后的size (called B) 与A 相等</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设4张照片</span></span><br><span class="line">a = tf.random.normal([<span class="number">4</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">3</span>])</span><br><span class="line">b = tf.pad(a,</span><br><span class="line">           [[<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">2</span>,<span class="number">2</span>], <span class="comment"># 每张照片上下填充2行</span></span><br><span class="line">            [<span class="number">2</span>,<span class="number">2</span>], <span class="comment"># 每张照片左右填充2列</span></span><br><span class="line">            [<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">          )</span><br><span class="line">b.shape <span class="comment"># TensorShape([4, 32, 32, 3])</span></span><br></pre></td></tr></table></figure>
<p>NLP padding</p>
<ul>
<li>为了使每个句子单词数量等长，需要padding，成为定长的句子。</li>
</ul>
<h4 id="tile"><a href="#tile" class="headerlink" title="tile"></a>tile</h4><p>真实的数据复制操作</p>
<ul>
<li>repeat data along dim <font color="red">n</font> times</li>
<li>[a,b,c], 2</li>
<li>-&gt; [a,b,c,a,b,c]</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.reshape(tf.range(<span class="number">9</span>),[<span class="number">3</span>,<span class="number">-1</span>]) <span class="comment"># TensorShape([3, 3])</span></span><br><span class="line">tf.tile(a, [<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[0, 1, 2, 0, 1, 2],</span></span><br><span class="line"><span class="string">       [3, 4, 5, 3, 4, 5],</span></span><br><span class="line"><span class="string">       [6, 7, 8, 6, 7, 8]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">tf.tile(a, [<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[0, 1, 2],</span></span><br><span class="line"><span class="string">       [3, 4, 5],</span></span><br><span class="line"><span class="string">       [6, 7, 8],</span></span><br><span class="line"><span class="string">       [0, 1, 2],</span></span><br><span class="line"><span class="string">       [3, 4, 5],</span></span><br><span class="line"><span class="string">       [6, 7, 8]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># Inner dim first</span></span><br><span class="line">tf.tile(a, [<span class="number">2</span>,<span class="number">2</span>])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[0, 1, 2, 0, 1, 2],</span></span><br><span class="line"><span class="string">       [3, 4, 5, 3, 4, 5],</span></span><br><span class="line"><span class="string">       [6, 7, 8, 6, 7, 8],</span></span><br><span class="line"><span class="string">       [0, 1, 2, 0, 1, 2],</span></span><br><span class="line"><span class="string">       [3, 4, 5, 3, 4, 5],</span></span><br><span class="line"><span class="string">       [6, 7, 8, 6, 7, 8]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h4 id="broadcast-to"><a href="#broadcast-to" class="headerlink" title="broadcast_to"></a>broadcast_to</h4><p>隐式复制，并没有真正复制，略</p>
<p>另外再次说明：有些操作符支持 broadcast，不需要显式调用也可以。比如 [4,3] + [3]</p>
<h3 id="张量限幅"><a href="#张量限幅" class="headerlink" title="张量限幅"></a>张量限幅</h3><h4 id="clip-by-value"><a href="#clip-by-value" class="headerlink" title="clip_by_value"></a>clip_by_value</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.range(<span class="number">10</span>) 		<span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment"># 单边限幅</span></span><br><span class="line">tf.maximum(a,<span class="number">2</span>)  		<span class="comment"># [2, 2, 2, 3, 4, 5, 6, 7, 8, 9]  max(a,2)</span></span><br><span class="line">tf.minimum(a,<span class="number">8</span>) 		<span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 8]  min(a,8)</span></span><br><span class="line"><span class="comment"># 双边限幅</span></span><br><span class="line">tf.clip_by_value(a,<span class="number">2</span>,<span class="number">8</span>)	<span class="comment"># [2, 2, 2, 3, 4, 5, 6, 7, 8, 8]  min(8, max(a,2))</span></span><br></pre></td></tr></table></figure>
<h4 id="relu"><a href="#relu" class="headerlink" title="relu"></a>relu</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = a - <span class="number">5</span> <span class="comment"># [-5, -4, -3, -2, -1,  0,  1,  2,  3,  4]</span></span><br><span class="line">tf.nn.relu(a) <span class="comment"># [0, 0, 0, 0, 0, 0, 1, 2, 3, 4]</span></span><br><span class="line">tf.maximum(a,<span class="number">0</span>) <span class="comment"># 同上</span></span><br></pre></td></tr></table></figure>
<h4 id="clip-by-norm"><a href="#clip-by-norm" class="headerlink" title="clip_by_norm"></a>clip_by_norm</h4><blockquote>
<p> descriptions: Clips tensor values to a maximum L2-norm. </p>
</blockquote>
<p>对于 vector（假设为(x,y) ） 有方向的概念，gradient 代表函数值增长最快的方向，在 gradient clipping 时（根据值来裁剪），如果裁剪x，不裁剪y，相当于改变了 vector 的方向，而同时希望 不改变 gradient 的方向。即：</p>
<ul>
<li>将值限制到较小的范围内</li>
<li>不改变 gradient 的方向</li>
</ul>
<p>我们可以采用等比例放缩：</p>
<script type="math/tex; mode=display">
\frac{(x,y)}{\|(x,y)\|}*clip\_norm</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = tf.random.normal([<span class="number">2</span>,<span class="number">2</span>], mean=<span class="number">10</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[[11.795398, 11.040575],</span></span><br><span class="line"><span class="string"> [ 9.601366, 11.682478]]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">tf.norm(a) <span class="comment"># 22.12899</span></span><br><span class="line">aa = tf.clip_by_norm(a, <span class="number">15</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[[7.995438 , 7.483786 ],</span></span><br><span class="line"><span class="string"> [6.508227 , 7.9188957]]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">tf.norm(aa) <span class="comment"># 15.0</span></span><br></pre></td></tr></table></figure>
<h4 id="gradient-clipping"><a href="#gradient-clipping" class="headerlink" title="gradient clipping"></a>gradient clipping</h4><p>Deep Learning 就是一个 gradient 的学科，所有的设计，不管是  批量归一化(Batch Normalization) 还是 学习率(Learning rate) 或者其他优化，选择 Adam 等 优化器，都是要创造良好的环境使得 gradient 能够很好的引导网络走向优良的方向（loss 下降的方向），这其中有两大障碍：</p>
<ul>
<li>gradient Exploding 值太大，步长长，导致来回震荡</li>
<li>gradient vanishing 值太小，很长时间原地不动</li>
</ul>
<p>对比 MINIST 数据集，很难看到这些障碍，这是因为数据太简单了，稍微复杂的情况，这两种情况很容易出现。为了复现这个问题，可以 set $lr=1$ </p>
<blockquote>
<p>体验使用 gradient clipping 使神经网络 运行的更好</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保证整体的 vector 方向不变，整理缩放比例一致</span></span><br><span class="line">new_grads, total_norm = tf.clip_by_global_norm(grad, <span class="comment"># t_list</span></span><br><span class="line">                                               <span class="number">25</span>, <span class="comment"># clip_norm</span></span><br><span class="line">                                               use_norm=<span class="literal">None</span>,</span><br><span class="line">                                               name=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 复现 gradient 问题 完整代码略</span></span><br><span class="line">(x, y), _ = tf.keras.datasets.mnist.load_data()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使 MNIST 出现 gradient 问题</span></span><br><span class="line">x = tf.convert_to_tensor(x, dtype=tf.float32) / <span class="number">50.</span></span><br><span class="line">optimizer = optimizers.SGD(lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># compute gradient</span></span><br><span class="line">grads = tape.gradient(loss, [w1, b1, w2, b2, w3, b3])</span><br><span class="line"></span><br><span class="line"><span class="comment"># before clip</span></span><br><span class="line">print(<span class="string">'==before=='</span>)</span><br><span class="line"><span class="keyword">for</span> g <span class="keyword">in</span> grads:</span><br><span class="line">    print(tf.norm(g))</span><br><span class="line"></span><br><span class="line"><span class="comment"># clip_by_global_norm</span></span><br><span class="line">grads, _ = tf.clip_by_global_norm(grads, <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># after clip</span></span><br><span class="line">print(<span class="string">'==after=='</span>)</span><br><span class="line"><span class="keyword">for</span> g <span class="keyword">in</span> grads:</span><br><span class="line">    print(tf.norm(g))</span><br></pre></td></tr></table></figure>
<p>使 MNIST 出现 gradient 问题：</p>
<ul>
<li>learning rate 设置大一些 0.01</li>
<li>输入限制到 0-5</li>
</ul>
<p>如果没有加入 clip_by_global_norm ，可能出现如下输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2.0</span><span class="number">.0</span></span><br><span class="line">x: (<span class="number">60000</span>, <span class="number">28</span>, <span class="number">28</span>) y: (<span class="number">60000</span>, <span class="number">10</span>)</span><br><span class="line">sample: (<span class="number">128</span>, <span class="number">28</span>, <span class="number">28</span>) (<span class="number">128</span>, <span class="number">10</span>)</span><br><span class="line">==before==</span><br><span class="line">tf.Tensor(<span class="number">85.98511</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">2.4999373</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">119.83714</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">2.1436949</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">132.3766</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">2.3793144</span>, shape=(), dtype=float32)</span><br><span class="line"><span class="number">0</span> loss: <span class="number">27.218223571777344</span></span><br><span class="line">==before==</span><br><span class="line">tf.Tensor(<span class="number">1364.3158</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">42.74355</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">1548.8491</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">28.97616</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">1484.8851</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">20.308739</span>, shape=(), dtype=float32)</span><br><span class="line">==before==</span><br><span class="line">tf.Tensor(<span class="number">193.77467</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">6.0404367</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">684.8617</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">6.861237</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">278.7067</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">6.103272</span>, shape=(), dtype=float32)</span><br><span class="line">==before==</span><br><span class="line">tf.Tensor(<span class="number">1023.0613</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">33.209797</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">2905.0632</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">30.36965</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">1529.8531</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">19.110842</span>, shape=(), dtype=float32)</span><br><span class="line">==before==</span><br><span class="line">tf.Tensor(<span class="number">460.32898</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">14.685878</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">1999.5978</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">14.543871</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">1581.0513</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">14.16413</span>, shape=(), dtype=float32)</span><br><span class="line">==before==</span><br><span class="line">tf.Tensor(<span class="number">242151.9</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">7056.0005</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">208297.53</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">1655.4941</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">275000.88</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">371.19373</span>, shape=(), dtype=float32)</span><br><span class="line">==before==</span><br><span class="line">tf.Tensor(<span class="number">5674674700.0</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">168005580.0</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">17948512000.0</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">8654475.0</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">7781239000.0</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">200822.3</span>, shape=(), dtype=float32)</span><br><span class="line">==before==</span><br><span class="line">tf.Tensor(inf, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(inf, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(inf, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(inf, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(inf, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">5.2273057e+17</span>, shape=(), dtype=float32)</span><br><span class="line">==before==</span><br><span class="line">tf.Tensor(nan, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(nan, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(nan, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(nan, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(nan, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(inf, shape=(), dtype=float32)</span><br><span class="line">==before==</span><br><span class="line">tf.Tensor(nan, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(nan, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(nan, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(nan, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(nan, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(nan, shape=(), dtype=float32)</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="number">100</span> loss: nan</span><br><span class="line"><span class="number">200</span> loss: nan</span><br><span class="line"><span class="number">300</span> loss: nan</span><br><span class="line"><span class="number">400</span> loss: nan</span><br><span class="line"><span class="number">500</span> loss: nan</span><br></pre></td></tr></table></figure>
<p>这一现象是 gradient Exploding ，加入 clip 后这一情况会得到改善</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">==before==</span><br><span class="line">tf.Tensor(<span class="number">82.41478</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">2.5339637</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">112.82711</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">2.1518593</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">133.68774</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">2.4968529</span>, shape=(), dtype=float32)</span><br><span class="line">==after==</span><br><span class="line">tf.Tensor(<span class="number">6.391338</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">0.19651109</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">8.749841</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">0.16687858</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">10.367601</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">0.19363312</span>, shape=(), dtype=float32)</span><br><span class="line"><span class="number">0</span> loss: <span class="number">26.43914031982422</span></span><br><span class="line">==before==</span><br><span class="line">tf.Tensor(<span class="number">29.091652</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">0.75837916</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">33.95014</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">0.5890228</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">36.167934</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">0.65747374</span>, shape=(), dtype=float32)</span><br><span class="line">==after==</span><br><span class="line">tf.Tensor(<span class="number">7.586649</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">0.19777344</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">8.853666</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">0.15360793</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">9.432032</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">0.17145889</span>, shape=(), dtype=float32)</span><br><span class="line">==before==</span><br><span class="line">tf.Tensor(<span class="number">32.28737</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">0.9371307</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">42.480125</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">0.8141749</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">49.03783</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">0.90850127</span>, shape=(), dtype=float32)</span><br><span class="line">==after==</span><br><span class="line">tf.Tensor(<span class="number">6.6815042</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">0.19392857</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">8.79078</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">0.16848427</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">10.147824</span>, shape=(), dtype=float32)</span><br><span class="line">tf.Tensor(<span class="number">0.18800406</span>, shape=(), dtype=float32)</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="number">0</span> loss: <span class="number">28.069189071655273</span></span><br><span class="line"><span class="number">100</span> loss: <span class="number">0.45802319049835205</span></span><br><span class="line"><span class="number">200</span> loss: <span class="number">0.1636555790901184</span></span><br><span class="line"><span class="number">300</span> loss: <span class="number">0.10513024032115936</span></span><br><span class="line"><span class="number">400</span> loss: <span class="number">0.09373171627521515</span></span><br><span class="line"><span class="number">500</span> loss: <span class="number">0.08014819771051407</span></span><br><span class="line"><span class="number">600</span> loss: <span class="number">0.08581136912107468</span></span><br><span class="line"><span class="number">700</span> loss: <span class="number">0.08369828015565872</span></span><br><span class="line"><span class="number">800</span> loss: <span class="number">0.07317458838224411</span></span><br><span class="line"><span class="number">900</span> loss: <span class="number">0.06344582885503769</span></span><br><span class="line"><span class="number">1000</span> loss: <span class="number">0.06460664421319962</span></span><br><span class="line"><span class="number">1100</span> loss: <span class="number">0.06235339492559433</span></span><br><span class="line"><span class="number">1200</span> loss: <span class="number">0.05849233269691467</span></span><br><span class="line"><span class="number">1300</span> loss: <span class="number">0.06183977425098419</span></span><br><span class="line"><span class="number">1400</span> loss: <span class="number">0.05234844610095024</span></span><br><span class="line"><span class="number">1500</span> loss: <span class="number">0.05308971926569939</span></span><br><span class="line"><span class="number">1600</span> loss: <span class="number">0.061960265040397644</span></span><br><span class="line"><span class="number">1700</span> loss: <span class="number">0.06077909469604492</span></span><br><span class="line"><span class="number">1800</span> loss: <span class="number">0.0626436173915863</span></span><br><span class="line"><span class="number">1900</span> loss: <span class="number">0.05248890072107315</span></span><br><span class="line"><span class="number">2000</span> loss: <span class="number">0.05477441847324371</span></span><br><span class="line"><span class="number">2100</span> loss: <span class="number">0.050197310745716095</span></span><br><span class="line"><span class="number">2200</span> loss: <span class="number">0.05866188555955887</span></span><br><span class="line"><span class="number">2300</span> loss: <span class="number">0.047177381813526154</span></span><br><span class="line"><span class="number">2400</span> loss: <span class="number">0.04807071015238762</span></span><br><span class="line"><span class="number">2500</span> loss: <span class="number">0.050419218838214874</span></span><br><span class="line"><span class="number">2600</span> loss: <span class="number">0.05031692981719971</span></span><br></pre></td></tr></table></figure>
<p>在自己做研究的时候，两种梯度问题会非常严重，这时候就需要采用 clip_by_global_norm 解决</p>
<h3 id="高阶OP"><a href="#高阶OP" class="headerlink" title="高阶OP"></a>高阶OP</h3><h4 id="where"><a href="#where" class="headerlink" title="where"></a>where</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.where(</span><br><span class="line">    condition,</span><br><span class="line">    x=<span class="literal">None</span>,</span><br><span class="line">    y=<span class="literal">None</span>,</span><br><span class="line">    name=<span class="literal">None</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>If both <code>x</code> and <code>y</code> are None, then this operation returns the coordinates of true elements of <code>condition</code>.  The coordinates are returned in a 2-D tensor where the first dimension (rows) represents the number of true elements, and the second dimension (columns) represents the coordinates of the true elements. Keep in mind, the shape of the output tensor can vary depending on how many true values there are in input. Indices are output in row-major order. </p>
<p>If both non-None, <code>condition</code>, <code>x</code> and <code>y</code> must be broadcastable to the same shape.</p>
<p>The <code>condition</code> tensor acts as a mask that chooses, based on the value at each element, whether the corresponding element / row in the output should be taken from <code>x</code> (if true) or <code>y</code> (if false).</p>
</blockquote>
<ul>
<li><p>如果一个参数，即只给定 condition，则返回 True 所在的坐标（coordinates）</p>
</li>
<li><p>如果三个参数，根据 condition 中的true/false进行选择值，true 则从x中取，false则从y中取</p>
<p>assert：这里的 true 是相对的，非0即true</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tf.where第一种用法：取坐标</span></span><br><span class="line"></span><br><span class="line">a = tf.random.normal([<span class="number">3</span>,<span class="number">3</span>])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ 0.524617  ,  1.2183112 , -0.22141142],</span></span><br><span class="line"><span class="string">       [-1.361392  , -0.98102844,  1.4004889 ],</span></span><br><span class="line"><span class="string">       [-1.1087296 ,  0.35734025, -0.6342832 ]]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">mask = a &gt; <span class="number">0</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ True,  True, False],</span></span><br><span class="line"><span class="string">       [False, False,  True],</span></span><br><span class="line"><span class="string">       [False,  True, False]])&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 以下两种实现是为了有目的性的选择</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># method1：根据mask 直接通过boolean_mask取值</span></span><br><span class="line"><span class="comment"># 取得 mask 上为 True 的 在 a 上对应位置的元素</span></span><br><span class="line">tf.boolean_mask(a, mask) <span class="comment"># [0.524617  , 1.2183112 , 1.4004889 , 0.35734025]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># method2：通过mask得到坐标，再用gather_nd 取值</span></span><br><span class="line"><span class="comment"># 查询 True 的坐标</span></span><br><span class="line">indices = tf.where(mask)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[0, 0],</span></span><br><span class="line"><span class="string">       [0, 1],</span></span><br><span class="line"><span class="string">       [1, 2],</span></span><br><span class="line"><span class="string">       [2, 1]], dtype=int64)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 结合 gather_nd 取值，结果跟 boolean_mask 一致</span></span><br><span class="line">tf.gather_nd(a, indices) <span class="comment"># [0.524617  , 1.2183112 , 1.4004889 , 0.35734025]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tf.where 第二种用法：取值</span></span><br><span class="line">mask</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[ True,  True, False],</span></span><br><span class="line"><span class="string">       [False, False,  True],</span></span><br><span class="line"><span class="string">       [False,  True, False]])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">A = tf.ones([<span class="number">3</span>,<span class="number">3</span>])</span><br><span class="line">B = tf.zeros([<span class="number">3</span>,<span class="number">3</span>])</span><br><span class="line">tf.where(mask, A, B)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[1., 1., 0.],</span></span><br><span class="line"><span class="string">       [0., 0., 1.],</span></span><br><span class="line"><span class="string">       [0., 1., 0.]], dtype=float32)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h4 id="scatter-nd"><a href="#scatter-nd" class="headerlink" title="scatter_nd"></a>scatter_nd</h4><p>根据坐标有目的性的更新，底板是全0，更新内容为：在 updates 上按照 indices 上的顺序和坐标进行更新。</p>
<p>使用灵活，但不是很easy</p>
<p><span class="exturl" data-url="aHR0cHM6Ly90ZW5zb3JmbG93Lmdvb2dsZS5jbi9hcGlfZG9jcy9weXRob24vdGYvc2NhdHRlcl9uZA==" title="https://tensorflow.google.cn/api_docs/python/tf/scatter_nd">https://tensorflow.google.cn/api_docs/python/tf/scatter_nd<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">indices = tf.constant([[<span class="number">4</span>], [<span class="number">3</span>], [<span class="number">1</span>], [<span class="number">7</span>]])</span><br><span class="line">updates = tf.constant([<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>])</span><br><span class="line">shape = tf.constant([<span class="number">8</span>])</span><br><span class="line">scatter = tf.scatter_nd(indices, updates, shape)</span><br><span class="line"><span class="comment"># [0, 11, 0, 10, 9, 0, 0, 12]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A + scatter 即指定位置上相加</span></span><br></pre></td></tr></table></figure>
<p>如果更新A的一部分值，先A要更新的一部分值取出来，更新到地板上后得到A1，A-A1 就会把要更新的内容清零，再把新的值写到底板A2，然后 清零后的+A2 即可。</p>
<p>TensorFlow 并不是专门为用户设计，而是内部实现能达到最精简的原则。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">indices = tf.constant([[<span class="number">0</span>], [<span class="number">2</span>]])</span><br><span class="line">updates = tf.constant([[[<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>],</span><br><span class="line">                        [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>],</span><br><span class="line">                        [<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>],</span><br><span class="line">                        [<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>]],</span><br><span class="line">                       [[<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>],</span><br><span class="line">                        [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>],</span><br><span class="line">                        [<span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>],</span><br><span class="line">                        [<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>]]])</span><br><span class="line">shape = tf.constant([<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line">scatter = tf.scatter_nd(indices, updates, shape)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[[5, 5, 5, 5],</span></span><br><span class="line"><span class="string">        [6, 6, 6, 6],</span></span><br><span class="line"><span class="string">        [7, 7, 7, 7],</span></span><br><span class="line"><span class="string">        [8, 8, 8, 8]],</span></span><br><span class="line"><span class="string">       [[0, 0, 0, 0],</span></span><br><span class="line"><span class="string">        [0, 0, 0, 0],</span></span><br><span class="line"><span class="string">        [0, 0, 0, 0],</span></span><br><span class="line"><span class="string">        [0, 0, 0, 0]],</span></span><br><span class="line"><span class="string">       [[5, 5, 5, 5],</span></span><br><span class="line"><span class="string">        [6, 6, 6, 6],</span></span><br><span class="line"><span class="string">        [7, 7, 7, 7],</span></span><br><span class="line"><span class="string">        [8, 8, 8, 8]],</span></span><br><span class="line"><span class="string">       [[0, 0, 0, 0],</span></span><br><span class="line"><span class="string">        [0, 0, 0, 0],</span></span><br><span class="line"><span class="string">        [0, 0, 0, 0],</span></span><br><span class="line"><span class="string">        [0, 0, 0, 0]]])&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h4 id="meshgrid"><a href="#meshgrid" class="headerlink" title="meshgrid"></a>meshgrid</h4><p>给定 x 和 y 的范围，生成点的范围</p>
<p>Points: </p>
<ul>
<li>x: -2 ~ 2，5个点</li>
<li>y: -2 ~ 2，5个点</li>
<li>Tensor:  [25,2] 25个点，每个点的坐标有2个数字表示</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Numpy</span></span><br><span class="line"><span class="comment"># 没有GPU加速，无法与tf深度结合在一起</span></span><br><span class="line">points = []</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> np.linspace(<span class="number">-2</span>,<span class="number">2</span>,<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> np.linspace(<span class="number">-2</span>,<span class="number">2</span>,<span class="number">5</span>):</span><br><span class="line">        points.append([x,y])</span><br><span class="line"><span class="keyword">return</span> np.array(points) <span class="comment"># (25, 2)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># GPU acceleration</span></span><br><span class="line">y = tf.linspace(<span class="number">-2.</span>,<span class="number">2</span>,<span class="number">5</span>) <span class="comment"># [-2., -1.,  0.,  1.,  2.]</span></span><br><span class="line">x = tf.linspace(<span class="number">-2.</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line">points_x, points_y = tf.meshgrid(x, y) <span class="comment"># TensorShape([5, 5])</span></span><br><span class="line"></span><br><span class="line">points_x</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[-2., -1.,  0.,  1.,  2.],</span></span><br><span class="line"><span class="string">       [-2., -1.,  0.,  1.,  2.],</span></span><br><span class="line"><span class="string">       [-2., -1.,  0.,  1.,  2.],</span></span><br><span class="line"><span class="string">       [-2., -1.,  0.,  1.,  2.],</span></span><br><span class="line"><span class="string">       [-2., -1.,  0.,  1.,  2.]], dtype=float32)&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">points_y</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">array([[-2., -2., -2., -2., -2.],</span></span><br><span class="line"><span class="string">       [-1., -1., -1., -1., -1.],</span></span><br><span class="line"><span class="string">       [ 0.,  0.,  0.,  0.,  0.],</span></span><br><span class="line"><span class="string">       [ 1.,  1.,  1.,  1.,  1.],</span></span><br><span class="line"><span class="string">       [ 2.,  2.,  2.,  2.,  2.]], dtype=float32)&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 如果拼接在一起就是shape为 [5,5,2] 的Tensor</span></span><br><span class="line">points = tf.stack([points_x, points_y], axis=<span class="number">2</span>)</span><br><span class="line">points.shape <span class="comment"># TensorShape([5, 5, 2])</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># meshgrid.py</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param x: [b, 2]</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    z = tf.math.sin(x[...,<span class="number">0</span>]) + tf.math.sin(x[...,<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> z</span><br><span class="line"></span><br><span class="line">x = tf.linspace(<span class="number">0.</span>, <span class="number">2</span>*<span class="number">3.14</span>, <span class="number">500</span>)</span><br><span class="line">y = tf.linspace(<span class="number">0.</span>, <span class="number">2</span>*<span class="number">3.14</span>, <span class="number">500</span>)</span><br><span class="line"><span class="comment"># [50, 50]</span></span><br><span class="line">point_x, point_y = tf.meshgrid(x, y)</span><br><span class="line"><span class="comment"># [50, 50, 2]</span></span><br><span class="line">points = tf.stack([point_x, point_y], axis=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># points = tf.reshape(points, [-1, 2])</span></span><br><span class="line">print(<span class="string">'points:'</span>, points.shape)</span><br><span class="line">z = func(points)</span><br><span class="line">print(<span class="string">'z:'</span>, z.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 已经得到x,y 和其对应的 z 的值，可以进行画图</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">plt.figure(<span class="string">'plot 2d func value'</span>)</span><br><span class="line">plt.imshow(z, origin=<span class="string">'lower'</span>, interpolation=<span class="string">'none'</span>)</span><br><span class="line">plt.colorbar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等高线图像</span></span><br><span class="line">plt.figure(<span class="string">'plot 2d func contour'</span>)</span><br><span class="line">plt.contour(point_x, point_y, z)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>好处：并行生成对应坐标轴系，而不需要 通过 for 循环 生成</p>
]]></content>
      <tags>
        <tag>深度学习</tag>
        <tag>TensorFlow 2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB学习笔记</title>
    <url>/2019/06/12/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="MongoDB命令行"><a href="#MongoDB命令行" class="headerlink" title="MongoDB命令行"></a>MongoDB命令行</h2><h3 id="全局性的命令"><a href="#全局性的命令" class="headerlink" title="全局性的命令"></a>全局性的命令</h3><h4 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use xx</span><br></pre></td></tr></table></figure>
<p>选择后，不论有没有该数据库都会执行成功，此时db被赋值为xx</p>
<h4 id="查看当前所有数据库"><a href="#查看当前所有数据库" class="headerlink" title="查看当前所有数据库"></a>查看当前所有数据库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show dbs</span><br></pre></td></tr></table></figure>
<h3 id="选定数据库后"><a href="#选定数据库后" class="headerlink" title="选定数据库后"></a>选定数据库后</h3><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> db.media.insertOne(&#123;</span><br><span class="line">    "Type":"Book",</span><br><span class="line">    "Title":"Definitive Guide to MongoDB 3rd ed.,The",</span><br><span class="line">    "ISBN":"978-1-4842-1183-0",</span><br><span class="line">    "Publisher":"Apress",</span><br><span class="line">    "Author":["Hows, David", "Plugge, Eelco", "Membrey, Peter", "Hawkins, Tim"]</span><br><span class="line">&#125;)</span><br><span class="line">db.media.insertOne(&#123;</span><br><span class="line">    "Type":"CD",</span><br><span class="line">    "Artist": "Nirvana",</span><br><span class="line">    "Title": "Nevermind",</span><br><span class="line">    "Tracklist":[</span><br><span class="line">        &#123;</span><br><span class="line">            "Track": "1",</span><br><span class="line">            "Title":"Smells Like Teen Spirit",</span><br><span class="line">            "Length":"5:02"</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            "Track":"2",</span><br><span class="line">            "Title": "In Bloom",</span><br><span class="line">            "Length":"4:15"</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="find-findOne"><a href="#find-findOne" class="headerlink" title="find/findOne"></a>find/findOne</h4><ul>
<li><p>第一个参数：查询限制条件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// key 可嵌套</span></span><br><span class="line">&#123; <span class="attr">key</span>: value &#125; <span class="comment">// value可以是数组中某一个元素</span></span><br><span class="line">&#123; <span class="attr">key</span>: &#123;object&#125; &#125; <span class="comment">// 必须完整</span></span><br><span class="line">&#123; <span class="attr">key</span>: &#123; <span class="attr">$gt</span>: <span class="number">2000</span> &#125; &#125;</span><br><span class="line">&#123; <span class="attr">$or</span> : [&#123;&#125;,&#123;&#125;]&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二个参数：显示结果限制</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0表示不显示，1表示只显示</span></span><br><span class="line">&#123; <span class="attr">key</span>: <span class="number">0</span>|<span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三个参数：限定结果数目，int</p>
</li>
<li>第四个参数：忽略前边多少个结果，int  </li>
</ul>
<h5 id="不带参数查询"><a href="#不带参数查询" class="headerlink" title="不带参数查询"></a>不带参数查询</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.media.find()</span><br></pre></td></tr></table></figure>
<p>返回集合中所有元素所有字段的数据</p>
<h5 id="限定查询条件"><a href="#限定查询条件" class="headerlink" title="限定查询条件"></a>限定查询条件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.media.find(&#123;Artist:"Nirvana"&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"_id"</span>: ObjectId(<span class="string">"5d00f69a7b3f3d22e3bb6b11"</span>),</span><br><span class="line">	<span class="attr">"Type"</span>: <span class="string">"CD"</span>,</span><br><span class="line">	<span class="attr">"Artist"</span>: <span class="string">"Nirvana"</span>,</span><br><span class="line">	<span class="attr">"Title"</span>: <span class="string">"Nevermind"</span>,</span><br><span class="line">	<span class="attr">"Tracklist"</span>: [&#123;</span><br><span class="line">		<span class="attr">"Track"</span>: <span class="string">"1"</span>,</span><br><span class="line">		<span class="attr">"Title"</span>: <span class="string">"Smells Like Teen Spirit"</span>,</span><br><span class="line">		<span class="attr">"Length"</span>: <span class="string">"5:02"</span></span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		<span class="attr">"Track"</span>: <span class="string">"2"</span>,</span><br><span class="line">		<span class="attr">"Title"</span>: <span class="string">"In Bloom"</span>,</span><br><span class="line">		<span class="attr">"Length"</span>: <span class="string">"4:15"</span></span><br><span class="line">	&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用点号</p>
<p>告诉 find 函数查找文档中内嵌的信息。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.media.find( &#123; "Tracklist.Title" : "In Bloom" &#125; )</span><br></pre></td></tr></table></figure>
<p>结果同上</p>
<h5 id="限定显示的字段"><a href="#限定显示的字段" class="headerlink" title="限定显示的字段"></a>限定显示的字段</h5><p>第二个参数加入，{key: 0|1}，0表示不显示，1表示显示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.media.find(&#123;Artist:"Nirvana"&#125;,&#123;Title:1&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"_id"</span>: ObjectId(<span class="string">"5d00f69a7b3f3d22e3bb6b11"</span>),</span><br><span class="line">	<span class="attr">"Title"</span>: <span class="string">"Nevermind"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.media.find(&#123;Artist:"Nirvana"&#125;,&#123;Title:1,_id:0&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"Title"</span> : <span class="string">"Nevermind"</span> &#125;</span><br></pre></td></tr></table></figure>
<h5 id="处理数组"><a href="#处理数组" class="headerlink" title="处理数组"></a>处理数组</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.media.find(&#123;"Author":"Membrey, Peter"&#125;)</span><br></pre></td></tr></table></figure>
<p>上述查询结果如下：第一层的key可以不精确匹配数组</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"_id"</span>: ObjectId(<span class="string">"5d00f5877b3f3d22e3bb6b10"</span>),</span><br><span class="line">	<span class="attr">"Type"</span>: <span class="string">"Book"</span>,</span><br><span class="line">	<span class="attr">"Title"</span>: <span class="string">"Definitive Guide to MongoDB 3rd ed.,The"</span>,</span><br><span class="line">	<span class="attr">"ISBN"</span>: <span class="string">"978-1-4842-1183-0"</span>,</span><br><span class="line">	<span class="attr">"Publisher"</span>: <span class="string">"Apress"</span>,</span><br><span class="line">	<span class="attr">"Author"</span>: [<span class="string">"Hows, David"</span>, <span class="string">"Plugge, Eelco"</span>, <span class="string">"Membrey, Peter"</span>, <span class="string">"Hawkins, Tim"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.media.find(&#123;"Tracklist":&#123;"Track":"1"&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>上述查询无结果，子对象必须精确匹配！！除非有下列的文档：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"Type"</span>:<span class="string">"CD"</span>,</span><br><span class="line">    <span class="attr">"Artist"</span>: <span class="string">"Nirvana"</span>,</span><br><span class="line">    <span class="attr">"Title"</span>: <span class="string">"Nevermind"</span>,</span><br><span class="line">    <span class="attr">"Tracklist"</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"Track"</span>: <span class="string">"1"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"Track"</span>:<span class="string">"2"</span>,</span><br><span class="line">            <span class="attr">"Title"</span>: <span class="string">"In Bloom"</span>,</span><br><span class="line">            <span class="attr">"Length"</span>:<span class="string">"4:15"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="find-sort、limit和skip"><a href="#find-sort、limit和skip" class="headerlink" title="find().sort、limit和skip"></a>find().sort、limit和skip</h4><p>可以像jQuery那样链式调用？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 升序排列</span></span><br><span class="line">db.student.find().sort( &#123; sno: 1&#125; )</span><br><span class="line"><span class="meta">#</span><span class="bash"> 降序排列</span></span><br><span class="line">db.student.find().sort( &#123; sno: -1&#125; )</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">limit</span> 限定最终结果数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> skip 忽略前n个文档</span></span><br><span class="line">db.student.find().sort( &#123; sno: -1&#125; ).limit(2).skip(0)</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 首先忽略开头20个文档，然后将结果数目限制为10个</span></span><br><span class="line">find(&#123;&#125;,&#123;&#125;,10,20)</span><br></pre></td></tr></table></figure>
<h4 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h4><h4 id="distinct-获取唯一值"><a href="#distinct-获取唯一值" class="headerlink" title="distinct()获取唯一值"></a>distinct()获取唯一值</h4><p>返回唯一值组成的列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> db.media.distinct(<span class="string">"Title"</span>)</span></span><br><span class="line">[ "Definitive Guide to MongoDB 3rd ed.,The", "Nevermind" ]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以嵌套键</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.media.distinct(<span class="string">"Tracklist.Title"</span>)</span></span><br><span class="line">[ "In Bloom", "Smells Like Teen Spirit" ]</span><br></pre></td></tr></table></figure>
<h3 id="结果分组"><a href="#结果分组" class="headerlink" title="结果分组"></a>结果分组</h3>]]></content>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2019/05/17/02-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="匹配单个字符"><a href="#匹配单个字符" class="headerlink" title="匹配单个字符"></a>匹配单个字符</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>含义</th>
<th>写法</th>
</tr>
</thead>
<tbody>
<tr>
<td>纯文本</td>
<td>w</td>
</tr>
<tr>
<td>任意字符</td>
<td>.</td>
</tr>
<tr>
<td>特殊字符</td>
<td>\\\\</td>
</tr>
<tr>
<td>集合中的一个字符</td>
<td>[abc] 、 [A-Za-z0-9]</td>
</tr>
<tr>
<td>不包含 集合中 任意一个字符</td>
<td><sup><a href="#fn_abc" id="reffn_abc">abc</a></sup></td>
</tr>
<tr>
<td>空白符</td>
<td>[\\b]、\f \\n \\r \\t \\r</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>Python中，’.’ 不能匹配’\n’ 。加入re.S后可以</p>
<p>集合中 也能放入\s \w这样的 单个元字符</p>
<p>[s]常常放入一个元素 与 ? 等重复匹配结合，增强可读性</p>
</blockquote>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><h4 id="空白字符类"><a href="#空白字符类" class="headerlink" title="空白字符类"></a>空白字符类</h4><div class="table-container">
<table>
<thead>
<tr>
<th>含义</th>
<th>写法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Backspace键，回退并删除</td>
<td>[\b]</td>
</tr>
<tr>
<td>换页符</td>
<td>\f</td>
</tr>
<tr>
<td>换行符</td>
<td>\n</td>
</tr>
<tr>
<td>回车符</td>
<td>\r</td>
</tr>
<tr>
<td>水平制表符</td>
<td>\t</td>
</tr>
<tr>
<td>垂直制表符</td>
<td>\v</td>
</tr>
<tr>
<td>任意一个空白字符</td>
<td>\s</td>
</tr>
<tr>
<td>任意一个非空白字符</td>
<td>\S</td>
</tr>
<tr>
<td>空格or水平制表符</td>
<td>[:blank:]</td>
</tr>
<tr>
<td>空白字符+空格</td>
<td>[:space:]</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>\r\n 匹配一个“回车+换行”组合，Windows的换行标识</p>
<p>\n Linux</p>
</blockquote>
<h4 id="数字、字母类"><a href="#数字、字母类" class="headerlink" title="数字、字母类"></a>数字、字母类</h4><div class="table-container">
<table>
<thead>
<tr>
<th>含义</th>
<th>写法</th>
</tr>
</thead>
<tbody>
<tr>
<td>任意一个数字字符[0-9]</td>
<td>\d</td>
</tr>
<tr>
<td>任意一个非数字字符</td>
<td>\D</td>
</tr>
<tr>
<td>任意一个字母数字或下划线</td>
<td>\w</td>
</tr>
<tr>
<td>上一行取反</td>
<td>\W</td>
</tr>
<tr>
<td>匹配十六进制</td>
<td>\x前缀</td>
</tr>
<tr>
<td>任何十六进制[a-fA-F0-9]</td>
<td>[:xdigit:]</td>
</tr>
<tr>
<td>匹配八进制</td>
<td>\0前缀</td>
</tr>
<tr>
<td>字母或数字</td>
<td>[:alnum:]</td>
</tr>
<tr>
<td>字母</td>
<td>[:alpha:]</td>
</tr>
<tr>
<td>数字</td>
<td>[:digit:]</td>
</tr>
<tr>
<td>小写字母</td>
<td>[:lower:]</td>
</tr>
<tr>
<td>大写字母</td>
<td>[:upper:]</td>
</tr>
</tbody>
</table>
</div>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><div class="table-container">
<table>
<thead>
<tr>
<th>含义</th>
<th>写法</th>
</tr>
</thead>
<tbody>
<tr>
<td>ASCII 控制字符</td>
<td>[:cntrl:]</td>
</tr>
<tr>
<td>可打印字符</td>
<td>[:print:]</td>
</tr>
<tr>
<td>可打印字符（空格除外）</td>
<td>[:graph:]</td>
</tr>
<tr>
<td>[:alnum:] 和 [:cntrl:] 之外的字符</td>
<td>[:punct:]</td>
</tr>
</tbody>
</table>
</div>
<h2 id="重复匹配问题"><a href="#重复匹配问题" class="headerlink" title="重复匹配问题"></a>重复匹配问题</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>重复次数</th>
<th>写法</th>
</tr>
</thead>
<tbody>
<tr>
<td>≥ 1 (贪婪)</td>
<td>+</td>
</tr>
<tr>
<td>≥ 1 (懒惰)</td>
<td>+?</td>
</tr>
<tr>
<td>≥ 0 (贪婪)</td>
<td>*</td>
</tr>
<tr>
<td>≥ 0 (懒惰)</td>
<td>*?</td>
</tr>
<tr>
<td>0 或 1</td>
<td>?</td>
</tr>
<tr>
<td>n</td>
<td>{n}</td>
</tr>
<tr>
<td>m ≤ 次数 ≤ n</td>
<td>{m,n}</td>
</tr>
<tr>
<td>≥ n (贪婪)</td>
<td>{n,}</td>
</tr>
<tr>
<td>≥ n (懒惰)</td>
<td>{n,}?</td>
</tr>
</tbody>
</table>
</div>
<h3 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h3><ul>
<li>紧挨着它的前一个 字符 / 元字符 / 子表达式</li>
</ul>
<h3 id="贪婪问题"><a href="#贪婪问题" class="headerlink" title="贪婪问题"></a>贪婪问题</h3><h4 id="匹配行为"><a href="#匹配行为" class="headerlink" title="匹配行为"></a>匹配行为</h4><ul>
<li>贪婪匹配：尽可能地从一段文本的开头一直匹配到这段文本的末尾</li>
<li>懒惰匹配：从这段文本的开头匹配到碰到第一个匹配时为止</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">B</span>&gt;</span>AK<span class="tag">&lt;/<span class="name">B</span>&gt;</span> and <span class="tag">&lt;<span class="name">B</span>&gt;</span>HI<span class="tag">&lt;/<span class="name">B</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;[Bb]&gt;.*?&lt;/B&gt;</span><br><span class="line"><span class="comment"># 会匹配两个B标签</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;[Bb]&gt;.*&lt;/B&gt;</span><br><span class="line"><span class="comment"># 所有内容都匹配到</span></span><br></pre></td></tr></table></figure>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>需要防止过度匹配的场合下，请使用“懒惰型”</li>
<li>区分 重复匹配是针对单个字符或一个字符集合，并不是 匹配的结果是否重复</li>
</ul>
<h2 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h2><h3 id="单词边界-b"><a href="#单词边界-b" class="headerlink" title="单词边界\b"></a>单词边界\b</h3><ul>
<li>\b 匹配一个单词的开始或结尾</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">\bcat\b  <span class="comment"># 匹配完整单词</span></span><br><span class="line">\bcat <span class="comment"># 匹配以cat开头的单词</span></span><br><span class="line">cat\b <span class="comment"># 匹配以cat结尾的单词</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串边界"><a href="#字符串边界" class="headerlink" title="字符串边界^$"></a>字符串边界^$</h3><p>^  匹配一个字符串的开头位置</p>
<p>$  匹配一个字符串的结束位置（换行结束位置）</p>
<blockquote>
<p>分行匹配模式(?m)</p>
<p>把行分隔符 当做 一个字符串的 分隔符 对待</p>
</blockquote>
<h2 id="子表达式（分组）"><a href="#子表达式（分组）" class="headerlink" title="子表达式（分组）"></a>子表达式（分组）</h2><h3 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h3><p>更大的表达式的一部分，当做一个 独立元素 来使用，需要用(和) 括起来；</p>
<p>可以用于整体 重复匹配问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(&amp;nbsp;)&#123;<span class="number">2</span>,&#125;</span><br></pre></td></tr></table></figure>
<p>也可以划分作用范围</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">19</span>|<span class="number">20</span>\d&#123;<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">19</span>|<span class="number">20</span>)\d&#123;<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>每个子表达式 都 加上 括号 会对匹配速度造成一定影响</p>
<p>?: 非捕获组</p>
</blockquote>
<h3 id="不同表达式之间的连接方式"><a href="#不同表达式之间的连接方式" class="headerlink" title="不同表达式之间的连接方式"></a>不同表达式之间的连接方式</h3><ul>
<li><p>对表达式的理解：</p>
<ul>
<li>单个元素，单个元字符为 独立的组成部分</li>
<li>通过()可以组合成一个整体</li>
<li>“整体”基础上，加上重复匹配等修饰，构成表达式</li>
</ul>
</li>
<li><p>连接方式</p>
<ul>
<li>不加任何修饰</li>
<li>或运算符 | ，两个表达式之间 2选1</li>
</ul>
</li>
</ul>
<h3 id="子表达式的嵌套"><a href="#子表达式的嵌套" class="headerlink" title="子表达式的嵌套"></a>子表达式的嵌套</h3><p>上述讨论的表达式可以继续 利用 或运算符，重复匹配等结合，形成新的表达式，进而形成一层层的嵌套。</p>
<p>理论上没有限制，但应该遵循适可而止的原则</p>
<h2 id="全局性的设置"><a href="#全局性的设置" class="headerlink" title="全局性的设置"></a>全局性的设置</h2><h3 id="匹配结果的问题g"><a href="#匹配结果的问题g" class="headerlink" title="匹配结果的问题g"></a>匹配结果的问题g</h3><ul>
<li>大部分 默认 返回第1个匹配结果</li>
<li>可以把 所有的匹配结果 全部找出来，返回一个数组或者 其他的专用格式</li>
</ul>
<h3 id="大小写问题"><a href="#大小写问题" class="headerlink" title="大小写问题"></a>大小写问题</h3><p>JavaScript可以用 i 标志 强制执行一次 不区分字母大小写的搜索</p>
<h3 id="分行匹配模式"><a href="#分行匹配模式" class="headerlink" title="分行匹配模式"></a>分行匹配模式</h3><p>(?m)必须出现在整个模式的最前面</p>
<blockquote>
<p>多数正则表达式 不支持</p>
</blockquote>
]]></content>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习笔记3-补充</title>
    <url>/2019/05/09/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h1 id="Python补充知识"><a href="#Python补充知识" class="headerlink" title="Python补充知识"></a>Python补充知识</h1><h2 id="一、异常"><a href="#一、异常" class="headerlink" title="一、异常"></a>一、异常</h2><h3 id="异常简介"><a href="#异常简介" class="headerlink" title="异常简介"></a>异常简介</h3><p>当使用Python解释器去执行代码的时候，遇到了错误，在控制台输出错误信息，这个错误信息就是异常</p>
<ul>
<li>代码遇到异常会终止执行  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">'zhangsan'</span></span><br><span class="line">name + <span class="number">10</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/images\4.png" alt="1557402111833"></p>
<ul>
<li>多数异常类 都 继承自 Exception 类</li>
<li></li>
</ul>
<h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>异常捕获通过try实现：</p>
<p>对于下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num1 = input(<span class="string">"请输入第一个数字："</span>)</span><br><span class="line">num2 = input(<span class="string">"请输入第二个数字："</span>)</span><br><span class="line"></span><br><span class="line">result = int(num1) + int(num2)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<p>如果不去捕获异常，输入字母时会出现如下结果：</p>
<p><img src="/images\5.png" alt="1557402366247"></p>
<p>ValueError继承自 Exception</p>
<p>添加异常捕获机制：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 把可能出现异常的代码放到try语句里</span></span><br><span class="line">    num1 = input(<span class="string">"请输入第一个数字："</span>)</span><br><span class="line">    num2 = input(<span class="string">"请输入第二个数字："</span>)</span><br><span class="line"></span><br><span class="line">    result = int(num1) + int(num2)</span><br><span class="line">    print(result)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e: <span class="comment"># e表示异常对象</span></span><br><span class="line">    <span class="comment"># 捕获到的异常会在except里边进行处理</span></span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure>
<p>输入不合法数据时出现如下结果：</p>
<p><img src="/images\6.png" alt="1557406548527"></p>
<p>当然可以捕获多种类型异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    name = <span class="string">'zs'</span></span><br><span class="line">    <span class="keyword">del</span> name</span><br><span class="line">    <span class="comment"># 在try里边如果执行代码遇到了异常，不会再try里边的后续代码，会执行except代码</span></span><br><span class="line">    print(name)</span><br><span class="line">    result = <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="comment"># 可以同时捕获多种类型异常</span></span><br><span class="line"><span class="keyword">except</span> (NameError, ZeroDivisionError) <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure>
<p>else和finally的使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = <span class="number">1</span> / <span class="number">0</span></span><br><span class="line"><span class="comment"># 可以同时捕获多种类型异常</span></span><br><span class="line"><span class="keyword">except</span> (NameError, ZeroDivisionError) <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"没有异常 --&gt; 会执行else"</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">"无论有没有异常 都会 执行finally语句"</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：</p>
<p>try语句块： 放可能出现异常的代码，一旦遇到异常不再执行后续语句，然后去对应except</p>
<p>except语句块：捕获到的异常处理（可以捕获多种类型异常），一般情况指定Exception即可</p>
<p>else语句块：没有异常时候，try执行完毕后执行此语句块</p>
<p>finally语句块：不论有无异常，最后都会执行此语句块</p>
</blockquote>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ul>
<li>自定义异常类继承自Exception</li>
<li>示例代码如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义异常类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomException</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, content)</span>:</span></span><br><span class="line">        self.content = content</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 表示抛出异常时 异常描述信息</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我是自定义异常，因为数据不是a，异常数据为%s"</span> % self.content</span><br><span class="line"></span><br><span class="line">content = input(<span class="string">"请输入数据"</span>)</span><br><span class="line"><span class="keyword">if</span> content != <span class="string">"a"</span>:</span><br><span class="line">    <span class="keyword">raise</span> CustomException(content)</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="/images\7.png" alt="1557660228911"></p>
<h3 id="手动抛出异常"><a href="#手动抛出异常" class="headerlink" title="手动抛出异常"></a>手动抛出异常</h3><p>在需要的地方用 raise 关键词 可以手动抛出异常，1.3 示例展示了 抛出自定义异常，当然也可以抛出系统异常。</p>
<p>不传入参数时候：<code>raise NameError()</code></p>
<p><img src="/images\8.png" alt="1557660902673"></p>
<p>如果传入了参数： <code>raise NameError(“异常信息”)</code>：</p>
<p><img src="/images\9.png" alt="1557660961891"></p>
<p>如果系统自己抛出异常，异常信息由系统指定：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p><img src="/images\10.png" alt="1557661102439"></p>
<blockquote>
<p>注意：raise 只能抛出异常类型</p>
</blockquote>
<h2 id="二、模块"><a href="#二、模块" class="headerlink" title="二、模块"></a>二、模块</h2><h3 id="模块的介绍"><a href="#模块的介绍" class="headerlink" title="模块的介绍"></a>模块的介绍</h3><ul>
<li>通俗理解模块就是一个.py文件，模块是管理功能代码的</li>
<li>模块里 可以定义类、定义函数、定义全局变量，也可以执行对应的功能代码操作</li>
</ul>
<h3 id="内置模块"><a href="#内置模块" class="headerlink" title="内置模块"></a>内置模块</h3><ul>
<li>Python自己内部的模块，比如time, random</li>
<li>用import导入后即可使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">print(<span class="string">"haha"</span>)</span><br><span class="line"><span class="comment"># 产生1~5之间的随机整数</span></span><br><span class="line">result = random.randint(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># 休眠1s</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h3><ul>
<li>理解：和变量名的定义 很类似，都是由 字母、数字、下划线组成，但不能以数字开头，否则无法导入。</li>
<li>命名规则和变量名的一样，统一使用下划线命名法</li>
<li>最好不能跟系统模块名字重复。否则导入该系统模块时就默认导入了 自定义模块</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># first_module.py 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义全局变量</span></span><br><span class="line">g_num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"There is a function"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_msg</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.name, self.age)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> first_module</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用模块中的代码</span></span><br><span class="line">print(first_module.g_num) <span class="comment"># 10</span></span><br><span class="line">first_module.show() <span class="comment"># There is a function</span></span><br><span class="line">stu = first_module.Student(<span class="string">"李四"</span>, <span class="number">20</span>)</span><br><span class="line">stu.show_msg() <span class="comment"># 李四 20</span></span><br></pre></td></tr></table></figure>
<h3 id="主模块"><a href="#主模块" class="headerlink" title="主模块"></a>主模块</h3><ul>
<li><p>含义：执行的这个模块就是主模块</p>
</li>
<li><p>查看模块名可以用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(__name)</span><br><span class="line"><span class="comment"># __main__ 表示主模块</span></span><br><span class="line"><span class="comment"># 否则输出当前模块名</span></span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
<p>被导入模块有输出的情况下，导入时会输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># second_module.py 文件</span></span><br><span class="line"></span><br><span class="line">g_score = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_info</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"show_info"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_num</span><span class="params">(num1, num2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line"></span><br><span class="line">print(__name__)</span><br><span class="line"><span class="comment"># 测试 sum_num有没有问题</span></span><br><span class="line">print(<span class="string">"second:"</span>, sum_num(<span class="number">1</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> second_module</span><br><span class="line">print(__name__)</span><br><span class="line">print(<span class="string">"当前模块:"</span>, second_module.sum_num(<span class="number">3</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">second_module</span><br><span class="line">second: 4</span><br><span class="line">__main__</span><br><span class="line">当前模块: 5</span><br></pre></td></tr></table></figure>
<p><strong>为了避免在 非 主模块测试的代码 影响 主模块，可以加入if判断</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改后的second_module.py 文件</span></span><br><span class="line">g_score = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_info</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"show_info"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_num</span><span class="params">(num1, num2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line"></span><br><span class="line">print(__name__)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 测试 sum_num有没有问题</span></span><br><span class="line">    print(<span class="string">"second:"</span>, sum_num(<span class="number">1</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>运行主模块后：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">second_module</span><br><span class="line">__main__</span><br><span class="line">当前模块: <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>可以发现”second: 4”不在执行</p>
<h3 id="模块的导入方式"><a href="#模块的导入方式" class="headerlink" title="模块的导入方式"></a>模块的导入方式</h3><p>见3.2</p>
<h3 id="模块导入的注意点"><a href="#模块导入的注意点" class="headerlink" title="模块导入的注意点"></a>模块导入的注意点</h3><ol>
<li>自定义模块名不要跟系统的模块名重名</li>
<li>导入的功能代码不要在当前模块定义，否则使用不了导入模块的功能代码</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">form first_module <span class="keyword">import</span> show</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"aaa"</span>)</span><br><span class="line"></span><br><span class="line">show() <span class="comment"># aaa</span></span><br></pre></td></tr></table></figure>
<p>推荐如下导入模块方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> first_module</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"aaa"</span>)</span><br><span class="line"></span><br><span class="line">show() <span class="comment"># aaa</span></span><br><span class="line">first_module.show() <span class="comment"># There is a function</span></span><br></pre></td></tr></table></figure>
<h3 id="模块搜索的顺序"><a href="#模块搜索的顺序" class="headerlink" title="模块搜索的顺序"></a>模块搜索的顺序</h3><ul>
<li><code>sys.path</code> </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&apos;C:\\Users\\73654\\PycharmProjects\\day01&apos;, &apos;C:\\Users\\73654\\PycharmProjects\\day01&apos;, &apos;C:\\Program Files\\JetBrains\\PyCharm 2019.1.1\\helpers\\pycharm_display&apos;, &apos;C:\\Users\\73654\\AppData\\Local\\Programs\\Python\\Python37\\python37.zip&apos;, &apos;C:\\Users\\73654\\AppData\\Local\\Programs\\Python\\Python37\\DLLs&apos;, &apos;C:\\Users\\73654\\AppData\\Local\\Programs\\Python\\Python37\\lib&apos;, &apos;C:\\Users\\73654\\AppData\\Local\\Programs\\Python\\Python37&apos;, &apos;C:\\Users\\73654\\PycharmProjects\\day01\\venv&apos;, &apos;C:\\Users\\73654\\PycharmProjects\\day01\\venv\\lib\\site-packages&apos;, &apos;C:\\Users\\73654\\AppData\\Roaming\\Python\\Python37\\site-packages&apos;, &apos;C:\\Users\\73654\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages&apos;, &apos;C:\\Users\\73654\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\win32&apos;, &apos;C:\\Users\\73654\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\win32\\lib&apos;, &apos;C:\\Users\\73654\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\Pythonwin&apos;, &apos;C:\\Program Files\\JetBrains\\PyCharm 2019.1.1\\helpers\\pycharm_matplotlib_backend&apos;]</span><br></pre></td></tr></table></figure>
<p>以上是在Pycharm中输出结果</p>
<h2 id="三、包"><a href="#三、包" class="headerlink" title="三、包"></a>三、包</h2><h3 id="包的介绍"><a href="#包的介绍" class="headerlink" title="包的介绍"></a>包的介绍</h3><ul>
<li>通俗理解：包就是一个文件夹，只不过文件夹中有一个__<em>init</em>__.py文件</li>
<li>包是管理模块的，模块是管理功能代码的</li>
</ul>
<h3 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h3><div class="table-container">
<table>
<thead>
<tr>
<th>导入模块方式</th>
<th>导入包方式</th>
<th>类型</th>
<th>限定</th>
</tr>
</thead>
<tbody>
<tr>
<td>import 模块名 [as 别名]</td>
<td><strong>import 包名.模块名 [as 别名]</strong></td>
<td>模块</td>
<td></td>
</tr>
<tr>
<td>from 模块名 import 功能代码 [as 别名]</td>
<td>form 包名.模块名 import 功能代码 [as 别名]</td>
<td>功能代码</td>
<td>需要保证当前模块没有导入模块的功能代码</td>
</tr>
<tr>
<td>from 模块名 import *</td>
<td></td>
<td>功能代码</td>
<td>可用__all__限定导入的功能代码</td>
</tr>
<tr>
<td></td>
<td><strong>from 包名 import 模块名 [as 别名]</strong></td>
<td>模块</td>
<td></td>
</tr>
<tr>
<td></td>
<td>from 包名 import *</td>
<td>模块</td>
<td>必须在__init__.py用__all__限定可导入的模块</td>
</tr>
<tr>
<td></td>
<td>import 包名</td>
<td></td>
<td>直接导入包，不会导入对应的模块，需要在init文件中自己导入</td>
</tr>
</tbody>
</table>
</div>
<h2 id="四、pip的使用"><a href="#四、pip的使用" class="headerlink" title="四、pip的使用"></a>四、pip的使用</h2><p>从网上下载并安装 第三方 的 包</p>
<p>pip 默认针对Python2</p>
<p>pip3 是针对Python3</p>
<p>常用命令：</p>
<ul>
<li><code>pip3 list</code> 查看当前安装了哪些包</li>
<li><code>pip3 uninstall xx</code> 删除xx包</li>
<li><code>pip3 install xx</code> 安装xx包</li>
</ul>
<p>辅助参数：</p>
<p>-i 指定源，国内的pip源如下：</p>
<p>阿里云 <span class="exturl" data-url="aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS9weXBpL3NpbXBsZS8=" title="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/<i class="fa fa-external-link"></i></span></p>
<p>中国科技大学 <span class="exturl" data-url="aHR0cHM6Ly9weXBpLm1pcnJvcnMudXN0Yy5lZHUuY24vc2ltcGxlLw==" title="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/ <i class="fa fa-external-link"></i></span></p>
<p>豆瓣(douban) <span class="exturl" data-url="aHR0cDovL3B5cGkuZG91YmFuLmNvbS9zaW1wbGUv" title="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/<i class="fa fa-external-link"></i></span></p>
<p>清华大学 <span class="exturl" data-url="aHR0cHM6Ly9weXBpLnR1bmEudHNpbmdodWEuZWR1LmNuL3NpbXBsZS8=" title="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/<i class="fa fa-external-link"></i></span></p>
<p>中国科学技术大学 <span class="exturl" data-url="aHR0cDovL3B5cGkubWlycm9ycy51c3RjLmVkdS5jbi9zaW1wbGUv" title="http://pypi.mirrors.ustc.edu.cn/simple/">http://pypi.mirrors.ustc.edu.cn/simple/<i class="fa fa-external-link"></i></span></p>
<h2 id="五、IO包"><a href="#五、IO包" class="headerlink" title="五、IO包"></a>五、IO包</h2><h3 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h3><p>把数据临时写入到内容，不想存到文件的时候可用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把字符串数据写入到内存</span></span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="comment"># StringIO的操作 与 文件的写入和读取 很类似</span></span><br><span class="line">str_io = io.StringIO()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向内存写入字符串数据</span></span><br><span class="line">str_io.write(<span class="string">"hello"</span>)</span><br><span class="line">str_io.write(<span class="string">"world"</span>)</span><br><span class="line"><span class="comment"># str_io.write("哈哈".encode("utf-8"))</span></span><br><span class="line"><span class="comment"># TypeError: string argument expected, got 'bytes'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line">content = str_io.getvalue()</span><br><span class="line">print(content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置文件指针的位置 到 文件开头</span></span><br><span class="line">str_io.seek(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 默认全部读取出来</span></span><br><span class="line">result = str_io.read()</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<h3 id="ByteIO"><a href="#ByteIO" class="headerlink" title="ByteIO"></a>ByteIO</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line">byte_io = BytesIO()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向内存写入数据</span></span><br><span class="line">byte_io.write(<span class="string">"哈哈"</span>.encode(<span class="string">"utf-8"</span>))</span><br><span class="line"><span class="comment"># 读取数据，获取写入到内存中的全部数据</span></span><br><span class="line">data = byte_io.getvalue()</span><br><span class="line">print(data)</span><br><span class="line"></span><br><span class="line">content = data.decode(<span class="string">"utf-8"</span>)</span><br><span class="line">print(content)</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b&apos;\xe5\x93\x88\xe5\x93\x88&apos;</span><br><span class="line">哈哈</span><br></pre></td></tr></table></figure>
<h2 id="六、序列化与反序列化pickle"><a href="#六、序列化与反序列化pickle" class="headerlink" title="六、序列化与反序列化pickle"></a>六、序列化与反序列化pickle</h2><p>pickle 对于任何对象都通用，不论是json还是 普通的自定义对象</p>
<p>pickle 序列化后得到的是二进制数据，需要注意文件的访问模式</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ul>
<li>把内存中的数据保存到本地，可以做到持久化存储</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">my_list = [&#123;<span class="string">"name"</span>: <span class="string">"李四"</span>, <span class="string">"age"</span>: <span class="number">20</span>&#125;, &#123;<span class="string">"name"</span>: <span class="string">"王五"</span>, <span class="string">"age"</span>: <span class="number">21</span>&#125;]</span><br><span class="line">file = open(<span class="string">"my_list.serialize"</span>, <span class="string">"wb"</span>)</span><br><span class="line">pickle.dump(my_list, file)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>
<p>得到的数据如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">�]q(&#125;q(XnameqX李四qXageqKu&#125;q(hX王五qhKue.</span><br></pre></td></tr></table></figure>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>把文件中的数据读取出来，得到保存的 Python对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">file = open(<span class="string">"my_list.serialize"</span>, <span class="string">"rb"</span>)</span><br><span class="line">my_list = pickle.load(file)</span><br><span class="line"></span><br><span class="line">print(my_list)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#123;&apos;name&apos;: &apos;李四&apos;, &apos;age&apos;: 20&#125;, &#123;&apos;name&apos;: &apos;王五&apos;, &apos;age&apos;: 21&#125;]</span><br></pre></td></tr></table></figure>
<h2 id="七、json序列化与反序列化"><a href="#七、json序列化与反序列化" class="headerlink" title="七、json序列化与反序列化"></a>七、json序列化与反序列化</h2><ul>
<li>只能支持部分数据类型，不通用。</li>
<li>支持 列表、字典、int类型，自定义类型不可以</li>
<li>以字符串的形式存储，而不是二进制数据</li>
</ul>
<h3 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">my_list = [&#123;<span class="string">"name"</span>: <span class="string">"李四"</span>, <span class="string">"age"</span>: <span class="number">20</span>&#125;, &#123;<span class="string">"name"</span>: <span class="string">"王五"</span>, <span class="string">"age"</span>: <span class="number">21</span>&#125;]</span><br><span class="line">file = open(<span class="string">"my_list.txt"</span>, <span class="string">"w"</span>, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">json.dump(my_list, file)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>
<p>文件中的数据如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#123;&quot;name&quot;: &quot;\u674e\u56db&quot;, &quot;age&quot;: 20&#125;, &#123;&quot;name&quot;: &quot;\u738b\u4e94&quot;, &quot;age&quot;: 21&#125;]</span><br></pre></td></tr></table></figure>
<h3 id="反序列化-1"><a href="#反序列化-1" class="headerlink" title="反序列化"></a>反序列化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">file = open(<span class="string">"my_list.txt"</span>, <span class="string">"r"</span>, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">my_list = json.load(file)</span><br><span class="line">print(my_list)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#123;&apos;name&apos;: &apos;李四&apos;, &apos;age&apos;: 20&#125;, &#123;&apos;name&apos;: &apos;王五&apos;, &apos;age&apos;: 21&#125;]</span><br></pre></td></tr></table></figure>
<h3 id="序列化对象的本质"><a href="#序列化对象的本质" class="headerlink" title="序列化对象的本质"></a>序列化对象的本质</h3><ul>
<li>序列化对象的本质是 把 对象的属性进行保存</li>
<li>用json没办法把对象序列化，只能序列化对象的__dict__</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">"李四"</span></span><br><span class="line">        self.age = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file = open(<span class="string">"stu.txt"</span>, <span class="string">"w"</span>, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">stu = Student()</span><br><span class="line">print(stu.__dict__)</span><br><span class="line">json.dump(stu.__dict__, file)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="string">"name"</span>: <span class="string">"\u674e\u56db"</span>, <span class="string">"age"</span>: <span class="number">20</span>&#125;, &#123;<span class="string">"name"</span>: <span class="string">"\u738b\u4e94"</span>, <span class="string">"age"</span>: <span class="number">21</span>&#125;]</span><br></pre></td></tr></table></figure>
<h2 id="八、可迭代对象"><a href="#八、可迭代对象" class="headerlink" title="八、可迭代对象"></a>八、可迭代对象</h2><h3 id="可迭代对象简介"><a href="#可迭代对象简介" class="headerlink" title="可迭代对象简介"></a>可迭代对象简介</h3><ul>
<li>可迭代对象 是 使用for循环遍历取值的对象</li>
<li>for循环可以直接遍历取值的对象：列表、元组、字典、字符串、集合、range</li>
</ul>
<h3 id="判断是否是可迭代对象"><a href="#判断是否是可迭代对象" class="headerlink" title="判断是否是可迭代对象"></a>判断是否是可迭代对象</h3><ul>
<li><p>可以导入 <code>collections</code>包中 <code>Iterable</code>模块</p>
<p>利用 <code>isinstance()</code> 方法判断是否是<strong>指定类型</strong><code>Iterable</code></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line">print(isinstance([<span class="number">1</span>, <span class="number">2</span>], Iterable))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果是from collections import Iterable会出现如下警告(Python 3.7.3rc1)</p>
<p>DeprecationWarning: Using or importing the ABCs from ‘collections’ instead of from ‘collections.abc’ is deprecated, and in 3.8 it will stop working<br>  from collections import Iterable</p>
</blockquote>
<ul>
<li><p>可迭代对象 都有一个 __iter__方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = dir([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&apos;__add__&apos;, &apos;__class__&apos;, &apos;__contains__&apos;, &apos;__delattr__&apos;, &apos;__delitem__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__getitem__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__iadd__&apos;, &apos;__imul__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__iter__&apos;, &apos;__le__&apos;, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__mul__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__reversed__&apos;, &apos;__rmul__&apos;, &apos;__setattr__&apos;, &apos;__setitem__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;append&apos;, &apos;clear&apos;, &apos;copy&apos;, &apos;count&apos;, &apos;extend&apos;, &apos;index&apos;, &apos;insert&apos;, &apos;pop&apos;, &apos;remove&apos;, &apos;reverse&apos;, &apos;sort&apos;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="九、迭代器"><a href="#九、迭代器" class="headerlink" title="九、迭代器"></a>九、迭代器</h2><h3 id="迭代器简介"><a href="#迭代器简介" class="headerlink" title="迭代器简介"></a>迭代器简介</h3><ul>
<li>迭代器：在类中有__iter__和__next__的方法 创建的对象 就是迭代器</li>
<li>作用：记录数据的位置，并根据这个位置获取下一个值（取值）</li>
<li>惰性取值，不会先把所有值生成好</li>
</ul>
<h3 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h3><p>自定义迭代器 类 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIterator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.my_list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">19</span>]</span><br><span class="line">        self.current_index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 返回迭代器对象</span></span><br><span class="line">        <span class="keyword">return</span>  self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.current_index &lt; len(self.my_list):</span><br><span class="line">            <span class="comment"># 获取迭代器中的下一个值</span></span><br><span class="line">            result = self.my_list[self.current_index]</span><br><span class="line">            self.current_index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 跑出停止迭代异常</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration(<span class="string">"停止迭代！"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="迭代器的遍历-迭代"><a href="#迭代器的遍历-迭代" class="headerlink" title="迭代器的遍历(迭代)"></a>迭代器的遍历(迭代)</h3><ul>
<li><p>手动next方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建迭代器</span></span><br><span class="line">my_iterator = MyIterator()</span><br><span class="line"><span class="comment"># 使用next函数获取迭代器中的下一个值</span></span><br><span class="line">result = next(my_iterator)</span><br><span class="line">print(result) <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line">result = next(my_iterator)</span><br><span class="line">print(result) <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line">result = next(my_iterator)</span><br><span class="line">print(result) <span class="comment"># 19</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">继续迭代会抛出异常……</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>for循环 内部 会自动处理 停止迭代异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建迭代器</span></span><br><span class="line">my_iterator = MyIterator()</span><br><span class="line"><span class="comment"># 使用next函数获取迭代器中的下一个值</span></span><br><span class="line">result = next(my_iterator)</span><br><span class="line">print(result) <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> my_iterator:</span><br><span class="line">    print(val) </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">19</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="十、生成器"><a href="#十、生成器" class="headerlink" title="十、生成器"></a>十、生成器</h2><h3 id="生成器简介"><a href="#生成器简介" class="headerlink" title="生成器简介"></a>生成器简介</h3><p>生成器是一个特殊的迭代器，根据一定的算法去生成数据。因此可用next函数和for循环取值</p>
<p>生成器和迭代器有一个共同的特点：节省内存</p>
<p>以往是 一次性 把所有数据都准备好，而它们则是 根据需要每次生成一个值</p>
<blockquote>
<p>值只能 往后取，不能往前</p>
</blockquote>
<h3 id="生成器创建方式"><a href="#生成器创建方式" class="headerlink" title="生成器创建方式"></a>生成器创建方式</h3><h4 id="使用生成器表达式"><a href="#使用生成器表达式" class="headerlink" title="使用生成器表达式"></a>使用生成器表达式</h4><p>跟列表生成器很类似，把[] 换成()即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">print(result) <span class="comment"># [0, 1, 2, 3]</span></span><br><span class="line">result = (x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">4</span>))</span><br><span class="line">print(result) <span class="comment"># &lt;generator object &lt;genexpr&gt; at 0x7f3792369318&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="使用yield创建生成器"><a href="#使用yield创建生成器" class="headerlink" title="使用yield创建生成器"></a>使用yield创建生成器</h4><p>先看一段实例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_num</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">value = show_num()</span><br><span class="line">print(value)</span><br></pre></td></tr></table></figure>
<p>执行return的时候函数就结束了，只能返回0</p>
<p>把return改成yield就是生成器了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_num</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = show_num()</span><br><span class="line">print(g)</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> g:</span><br><span class="line">    print(val)</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<ul>
<li>yield特点：<ul>
<li>代码遇到yield会暂停，然后把结果返回出去</li>
<li>下次启动生成器在暂停的位置继续往下执行</li>
<li>可以返回多次值</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_num</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(<span class="string">"1111"</span>)</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        print(<span class="string">"2222"</span>)</span><br><span class="line"></span><br><span class="line">g = show_num()</span><br><span class="line">print(next(g))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1111</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_num</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(<span class="string">"1111"</span>)</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        print(<span class="string">"2222"</span>)</span><br><span class="line"></span><br><span class="line">g = show_num()</span><br><span class="line">print(next(g))</span><br><span class="line">print(next(g))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1111</span><br><span class="line">0</span><br><span class="line">2222</span><br><span class="line">1111</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="生成器遍历"><a href="#生成器遍历" class="headerlink" title="生成器遍历"></a>生成器遍历</h3><p>同迭代器(next和for)</p>
<h2 id="十一、线程"><a href="#十一、线程" class="headerlink" title="十一、线程"></a>十一、线程</h2><h3 id="线程是什么"><a href="#线程是什么" class="headerlink" title="线程是什么"></a>线程是什么</h3><p>之前所学的代码无法完成多任务，没办法两个函数“同时”执行，以前的代码都只有一条线程，只能按照调用的先后顺序依次执行</p>
<ul>
<li>线程：执行代码的分支，默认程序只有一个线程</li>
<li>线程执行是无序的，由CPU调度决定</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AA</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        print(i, <span class="string">"aa"</span>)</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BB</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        print(i, <span class="string">"bb"</span>)</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    AA()</span><br><span class="line">    BB()</span><br></pre></td></tr></table></figure>
<p>上述代码会先执行AA()，执行完毕后才会去执行BB()</p>
<h3 id="多线程的代码实现"><a href="#多线程的代码实现" class="headerlink" title="多线程的代码实现"></a>多线程的代码实现</h3><ul>
<li>引入<code>threading</code> 模块</li>
<li><p><code>Thread()</code>函数创建子线程，参数说明：</p>
<ul>
<li><code>target</code> 参数接收 目标函数</li>
<li><code>daemon</code> 为True时，守护主线程</li>
<li><code>args</code> 以元组形式给 目标函数传参</li>
<li><code>kwargs</code> 以字典形式给 目标函数传参</li>
</ul>
</li>
<li><p><code>ThreadObject.start()</code> 启动线程，线程对应函数的代码才会执行</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AA</span><span class="params">(count)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">        print(i, <span class="string">"aa"</span>)</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BB</span><span class="params">(count)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">        print(i, <span class="string">"bb"</span>)</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建子线程，执行对应的代码，target表示目标函数</span></span><br><span class="line">    sub_thread1 = threading.Thread(target=AA, kwargs=&#123;<span class="string">"count"</span>: <span class="number">3</span>&#125;)</span><br><span class="line">    sub_thread1.start()</span><br><span class="line">    sub_thread2 = threading.Thread(target=BB, args=(<span class="number">3</span>,))</span><br><span class="line">    sub_thread2.start()</span><br></pre></td></tr></table></figure>
<p>示例输出（多线程输出结果不确定）：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> aa</span><br><span class="line"><span class="number">0</span> bb</span><br><span class="line"><span class="number">1</span> aa</span><br><span class="line"><span class="number">1</span> bb</span><br><span class="line"><span class="number">2</span> bb</span><br><span class="line"><span class="number">2</span> aa</span><br></pre></td></tr></table></figure>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><ul>
<li><p>默认情况下，主线程会等待所有的子线程执行完成以后再退出</p>
<ul>
<li>如果是子线程中有死循环，主线程不会退出</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AA</span><span class="params">(count)</span>:</span></span><br><span class="line">    print(<span class="string">"AA:"</span>, threading.current_thread())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">        print(i, <span class="string">"aa"</span>)</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"main:"</span>, threading.current_thread())</span><br><span class="line">    t1 = threading.Thread(target=AA, kwargs=&#123;<span class="string">"count"</span>: <span class="number">3</span>&#125;)</span><br><span class="line">    t1.start()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"over"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main: &lt;_MainThread(MainThread, started 140719848908608)&gt;</span><br><span class="line">AA: &lt;Thread(Thread-1, started 140719843464960)&gt;</span><br><span class="line">0 aa</span><br><span class="line">over</span><br><span class="line">1 aa</span><br><span class="line">2 aa</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置守护线程</p>
<ul>
<li>主线程退出的时候，子线程直接销毁，不再执行对应的代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = threading.Thread(target=AA, kwargs=&#123;<span class="string">"count"</span>: <span class="number">3</span>&#125;)</span><br><span class="line">t1.setDaemon(<span class="literal">True</span>)</span><br><span class="line">t1.start()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">print(<span class="string">"over"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 aa</span><br><span class="line">1 aa</span><br><span class="line">2 aa</span><br><span class="line">over</span><br></pre></td></tr></table></figure>
<p>除了用setDaemon(True) 的方式外，还可以</p>
<p>在创建线程的时候，传入Daemon参数达到守护线程的目的</p>
</li>
</ul>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>先观察下面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AA</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    print(<span class="string">"AA:"</span>, g_num)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BB</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    print(<span class="string">"BB:"</span>, g_num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建两个线程</span></span><br><span class="line">    first_thread = threading.Thread(target=AA)</span><br><span class="line">    second_thread = threading.Thread(target=BB)</span><br><span class="line">    </span><br><span class="line">    first_thread.start()</span><br><span class="line">    second_thread.start()</span><br></pre></td></tr></table></figure>
<p>输出结果不确定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BB: 1385465</span><br><span class="line">AA: 1545123</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AA: 1550914</span><br><span class="line">BB: 1565660</span><br></pre></td></tr></table></figure>
<p>……</p>
<p>两个线程同时对 同一个全局变量 操作 出现了资源竞争问题，可以用互斥锁解决</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line"><span class="comment"># 创建互斥锁</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AA</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 上锁</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    print(<span class="string">"AA:"</span>, g_num)</span><br><span class="line">    <span class="comment"># 释放锁</span></span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BB</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 上锁</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    print(<span class="string">"BB:"</span>, g_num)</span><br><span class="line">    <span class="comment"># 释放锁</span></span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建两个线程</span></span><br><span class="line">    first_thread = threading.Thread(target=AA)</span><br><span class="line">    second_thread = threading.Thread(target=BB)</span><br><span class="line"></span><br><span class="line">    first_thread.start()</span><br><span class="line">    second_thread.start()</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AA: 1000000</span><br><span class="line">BB: 2000000</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：视频在此位置有 跳跃，一段视频消失了……</p>
<p>GIL 全局解释器锁：CPython内置</p>
<p>Python的多线程不是真正意义上的多线程，没办法让两个线程”同时”执行，Python解释器会让某一线程先执行（上锁），其他线程等待一小段时间（释放锁）</p>
</blockquote>
<h2 id="十二、进程"><a href="#十二、进程" class="headerlink" title="十二、进程"></a>十二、进程</h2><h3 id="进程是什么"><a href="#进程是什么" class="headerlink" title="进程是什么"></a>进程是什么</h3><ul>
<li>进程：每次创建一个进程，操作系统会给这个进程分配对应的运行资源，一个进程里面默认有一个线程</li>
<li>真正干活的是线程，进程只提供资源</li>
<li>使用进程也可以完成多任务</li>
</ul>
<h3 id="进程的代码实现"><a href="#进程的代码实现" class="headerlink" title="进程的代码实现"></a>进程的代码实现</h3><p>大体上跟 线程 类似</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(<span class="string">"show"</span>)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(<span class="string">"show1"</span>)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建子进程</span></span><br><span class="line">    first = multiprocessing.Process(target=show)</span><br><span class="line">    second = multiprocessing.Process(target=show1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动进程执行任务</span></span><br><span class="line">    first.start()</span><br><span class="line">    second.start()</span><br></pre></td></tr></table></figure>
<h3 id="在主进程终止子进程"><a href="#在主进程终止子进程" class="headerlink" title="在主进程终止子进程"></a>在主进程终止子进程</h3><ul>
<li>默认情况下，主进程会等到子进程执行完成后再退出（同线程）</li>
</ul>
<ol>
<li><p>让子进程终止，销毁子进程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sub_process.terminate()</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置守护进程（同线程）</p>
</li>
</ol>
<h3 id="共享全局变量问题"><a href="#共享全局变量问题" class="headerlink" title="共享全局变量问题"></a>共享全局变量问题</h3><p>进程之间是相互独立的，只是变量名相同而已，不会共享全局变量的数据</p>
<p>子进程会对主进程的资源进行拷贝</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line">my_list = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_data</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        my_list.append(i)</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"add_data:"</span>, my_list)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"read:"</span>, my_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建两个子进程</span></span><br><span class="line">    add_process = multiprocessing.Process(target=add_data)</span><br><span class="line">    read_process = multiprocessing.Process(target=read_data)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 启动进程执行任务</span></span><br><span class="line">    add_process.start()</span><br><span class="line">    <span class="comment"># 进程等待，主进程等待子进程执行完，再让后边的代码执行</span></span><br><span class="line">    add_process.join()</span><br><span class="line">    read_process.start()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add_data: [0, 1, 2]</span><br><span class="line">read: []</span><br></pre></td></tr></table></figure>
<h3 id="进程之间的通信方式"><a href="#进程之间的通信方式" class="headerlink" title="进程之间的通信方式"></a>进程之间的通信方式</h3><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><ul>
<li>消息队列的 添加和获取数据<ul>
<li><code>Queue()</code> 创建空队列，容量默认为任意多个，可以指定</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建消息队列</span></span><br><span class="line">queue = multiprocessing.Queue(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 往队列添加数据</span></span><br><span class="line">queue.put(<span class="number">1</span>)</span><br><span class="line">queue.put(<span class="number">2</span>)</span><br><span class="line">queue.put(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从队列中获取数据</span></span><br><span class="line">print(queue.get())</span><br></pre></td></tr></table></figure>
<ul>
<li>用消息队列实现在 进程之间共享数据<ul>
<li>创建一个队列</li>
<li>以参数的形式传到各个进程</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_data</span><span class="params">(queue)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        print(<span class="string">"add:"</span>, i)</span><br><span class="line">        queue.put(i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data</span><span class="params">(queue)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> queue.empty():</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        value = queue.get()</span><br><span class="line">        print(<span class="string">"get:"</span>, value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    queue = multiprocessing.Queue(<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 创建两个子进程</span></span><br><span class="line">    add_process = multiprocessing.Process(target=add_data, args=(queue,))</span><br><span class="line">    read_process = multiprocessing.Process(target=read_data, args=(queue,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动进程执行任务</span></span><br><span class="line">    add_process.start()</span><br><span class="line">    <span class="comment"># 进程等待，主进程等待子进程执行完，再让后边的代码执行</span></span><br><span class="line">    add_process.join()</span><br><span class="line">    read_process.start()</span><br></pre></td></tr></table></figure>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><blockquote>
<p>多任务：使用线程和进程</p>
<p>从资源角度来说，线程更加节省资源，进程消耗资源较多</p>
<p>从代码稳定性来说，多进程比多线程稳定性要强，因为一个进程挂掉不会影响其他进程</p>
</blockquote>
]]></content>
      <categories>
        <category>Python学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习笔记2-Python面向对象</title>
    <url>/2019/05/08/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="面向对象和面向过程"><a href="#面向对象和面向过程" class="headerlink" title="面向对象和面向过程"></a>面向对象和面向过程</h2><p>都是开发程序的模式</p>
<ul>
<li>面向过程是 自己按照实现过程的步骤，完成功能的开发</li>
<li>面对对象是 程序员找一个功能对象，功能对象里边提供功能方法，程序员只负责调度，不关心具体实现</li>
</ul>
<h2 id="类和对象的介绍"><a href="#类和对象的介绍" class="headerlink" title="类和对象的介绍"></a>类和对象的介绍</h2><ul>
<li>类：事或者物一个分类</li>
<li>对象：具体到某一个事或者物</li>
</ul>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><ul>
<li>需要用class关键字</li>
<li>类中有 属性(特征) 方法(行为)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义学生类，这是旧式类</span></span><br><span class="line"><span class="comment"># Python2 中无父类</span></span><br><span class="line"><span class="comment"># Python3 中 旧式类 默认集成object</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="comment"># 属性</span></span><br><span class="line">    country = <span class="string">"China"</span></span><br><span class="line">    <span class="comment"># 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"我是学生"</span>)</span><br><span class="line"><span class="comment"># 通过类创建对象</span></span><br><span class="line">stu = Student()</span><br><span class="line">stu.show()</span><br><span class="line"></span><br><span class="line">print(Student.__bases__) <span class="comment"># (&lt;class 'object'&gt;,)</span></span><br></pre></td></tr></table></figure>
<p>新式类，即主动指定继承的父类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    country = <span class="string">"China"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h2 id="给对象添加属性信息"><a href="#给对象添加属性信息" class="headerlink" title="给对象添加属性信息"></a>给对象添加属性信息</h2><p>Python对象创建后可以动态的添加属性……</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Hello"</span>)</span><br><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">stu = Student()</span><br><span class="line"><span class="comment"># 动态添加对象属性</span></span><br><span class="line">stu.name = <span class="string">"zhangsan"</span></span><br><span class="line">stu.age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取对象属性</span></span><br><span class="line">print(stu.name, stu.age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改对象属性</span></span><br><span class="line">stu.name = <span class="string">"wangwu"</span></span><br><span class="line">print(stu.name, stu.age)</span><br></pre></td></tr></table></figure>
<p>每次这样手动添加会比较复杂，用5.1方法可以解决</p>
<h2 id="魔法方法"><a href="#魔法方法" class="headerlink" title="魔法方法"></a>魔法方法</h2><ul>
<li>魔法方法：当需要完成某个功能操作的时候会自动调用某个方法</li>
<li>表现形式：__ 开始和结束</li>
</ul>
<h3 id="init"><a href="#init" class="headerlink" title="__init__"></a>__<em>init</em>__</h3><ul>
<li>作用：对象创建完成会调用此方法，给对象初始化，添加属性</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        <span class="comment"># self 表示当前对象</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        print(<span class="string">"__init__ called"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_info</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.name, self.age)</span><br><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">stu1 = Student(<span class="string">"zhangsan"</span>, <span class="number">18</span>)</span><br><span class="line">stu1.show_info()</span><br><span class="line">stu2 = Student(<span class="string">"lisi"</span>, <span class="number">20</span>)</span><br><span class="line">stu2.show_info()</span><br></pre></td></tr></table></figure>
<h3 id="str"><a href="#str" class="headerlink" title="__str__"></a>__str__</h3><ul>
<li>作用：使用print打印对象的时候会自动调用</li>
<li>需要返回字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 返回一个字符串信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我叫%s 年龄%d"</span> % (self.name, self.age)</span><br><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">stu1 = Student(<span class="string">"zhangsan"</span>, <span class="number">18</span>)</span><br><span class="line">print(stu1)</span><br><span class="line">stu2 = Student(<span class="string">"lisi"</span>, <span class="number">20</span>)</span><br><span class="line">print(stu2)</span><br></pre></td></tr></table></figure>
<h3 id="del"><a href="#del" class="headerlink" title="__del__"></a>__del__</h3><ul>
<li><p>作用：当对象释放的时候会自动调用</p>
</li>
<li><p>调用的时机：</p>
<ul>
<li>程序退出，程序中所使用的对象全部销毁</li>
<li>当前对象的内存地址没有变量使用的时候会销毁<ul>
<li>del 手动删除</li>
<li>引用计数机制</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="comment"># 当对象引用计数为0的时候调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"object is killed:"</span>, self)</span><br><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">stu1 = Student(<span class="string">"zhangsan"</span>, <span class="number">18</span>)</span><br><span class="line">print(stu1) <span class="comment"># &lt;__main__.Student object at 0x00000220AE3454E0&gt;</span></span><br><span class="line">stu2 = stu1</span><br><span class="line"><span class="keyword">del</span> stu1</span><br><span class="line"><span class="keyword">del</span> stu2</span><br><span class="line"><span class="comment"># object is killed: &lt;__main__.Student object at 0x00000220AE3454E0&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="new"><a href="#new" class="headerlink" title="__new__"></a>__new__</h3><ul>
<li>作用：当 创建对象的时候会调用</li>
</ul>
<blockquote>
<p>创建对象会自动调用两个方法，先new表示对象创建完成再init对对象进行初始化</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># new方法里边的参数 是 需要兼容init方法 的参数,因此才会有*args, **kwargs</span></span><br><span class="line">    <span class="comment"># TypeError: __new__() takes 1 positional argument but 3 were given</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"创建对象"</span>)</span><br><span class="line">        <span class="keyword">return</span> object.__new__(cls)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        print(<span class="string">"初始化对象"</span>)</span><br><span class="line"></span><br><span class="line">stu = Student(<span class="string">"zs"</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li>子类继承父类，可以使用父类的属性和方法</li>
<li></li>
</ul>
<h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><ul>
<li>子类只继承一个父类</li>
</ul>
<p><img src="/images/1557370696885.png" alt="1557370745487"></p>
<p><img src="/images/2.png" alt="1557370786341"></p>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><ul>
<li>相当于继承多个父类</li>
<li>Python方法的调用会遵循mro，类继承顺序，决定了方法调用时候的查找顺序</li>
<li>调用类的mro方法可以查看类继承顺序</li>
</ul>
<h3 id="重写父类方法"><a href="#重写父类方法" class="headerlink" title="重写父类方法"></a>重写父类方法</h3><ul>
<li>重写：子类继承父类，父类的方法满足不了子类的需要，可以对父类的方法进行重写</li>
<li>子类调用方法的时候先从本类查找，如果没有再去父类，遵循mro的特点</li>
<li>特点：<ul>
<li>继承关系</li>
<li>方法名相同</li>
</ul>
</li>
</ul>
<h3 id="调用父类的方法"><a href="#调用父类的方法" class="headerlink" title="调用父类的方法"></a>调用父类的方法</h3><h4 id="一般方法"><a href="#一般方法" class="headerlink" title="一般方法"></a>一般方法</h4><ul>
<li><p>当前类里边没有父类的方法时</p>
<ul>
<li>self.method()</li>
<li>如果有则调用当前类的方法</li>
</ul>
</li>
<li><p>当前类复写了父类相同方法时</p>
<ul>
<li><p>父类类名.method(self)</p>
<ul>
<li>必须手动传递self</li>
</ul>
</li>
<li><p>super(类名, self).method()</p>
<ul>
<li>根据指定类，在类继承链中获取下一个类</li>
<li>类名，表示根据这个类 找 类继承链 中获取下一个类</li>
<li>self 表示获取self对象类型的类继承链</li>
<li>super不一定是直接继承的父类<ul>
<li>单继承理解成父类没问题</li>
<li>多继承需要看 继承链</li>
</ul>
</li>
<li>用Super更加通用，但跟其他语言的super含义不一样</li>
</ul>
<blockquote>
<p>在self继承链中，返回 类名的下一个类</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="调用父类-init-方法"><a href="#调用父类-init-方法" class="headerlink" title="调用父类 __init__ 方法"></a>调用父类 __<em>init</em>__ 方法</h4><p>如果子类提供了方法，需要父类的相同方法时，才需要调用super</p>
<ul>
<li><code>self.__init__(param)</code>  不可取</li>
<li>父类类名.__init__(self, param)</li>
<li><code>super(父类, self).__init__(param)</code><ul>
<li>参数可省略<code>super().__init__(param)</code></li>
</ul>
</li>
</ul>
<h4 id="重写父类中使用super"><a href="#重写父类中使用super" class="headerlink" title="重写父类中使用super"></a>重写父类中使用super</h4><p><img src="/images\3.png" alt="1557372784039"></p>
<h3 id="私有属性和私有方法"><a href="#私有属性和私有方法" class="headerlink" title="私有属性和私有方法"></a>私有属性和私有方法</h3><ul>
<li>在属性名和方法名<strong>前面</strong>加上’__‘  就是私有的</li>
<li>私有属性外界无法访问，只能在本类中使用</li>
<li>只能在__<em>init</em>__ 中添加</li>
<li>在Python中 私有xx没有做到绝对私有，只是把xx进行了一个名字的伪装</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        <span class="comment"># 公共属性</span></span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># 私有属性,只能在本类内部使用，在类外部不能使用</span></span><br><span class="line">        <span class="comment"># 只能在__init__中添加私有属性</span></span><br><span class="line">        self.__age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.name)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__money</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"100W"</span>)</span><br><span class="line">person = Person(<span class="string">"zhangsan"</span>, <span class="number">20</span>)</span><br><span class="line">print(person.name)</span><br><span class="line"><span class="comment"># 私有属性外界访问不了</span></span><br><span class="line"><span class="comment"># print(person.__age)</span></span><br><span class="line"><span class="comment"># person.__money()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看对象中的属性信息</span></span><br><span class="line">print(person.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本意是修改私有属性</span></span><br><span class="line"><span class="comment"># 这里不是修改了私有属性，而是动态添加了一个__age对象属性</span></span><br><span class="line"><span class="comment"># 提示:这里也不是添加的私有属性，只能在__init__中添加</span></span><br><span class="line">person.__age = <span class="number">22</span></span><br><span class="line">print(person.__age)</span><br><span class="line">print(person.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不是绝对的私有, 以下操作 不是常规操作，不建议这样使用</span></span><br><span class="line">print(person._Person__age) <span class="comment"># 20</span></span><br><span class="line">person._Person__money() <span class="comment"># 100W</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：子类继承父类，不能直接使用父类的私有属性和私有方法</p>
</blockquote>
<h2 id="类属性和实例属性"><a href="#类属性和实例属性" class="headerlink" title="类属性和实例属性"></a>类属性和实例属性</h2><ul>
<li><strong>类属性</strong>是在 方法外 和 类内部 定义的属性<ul>
<li>类和对象都能访问</li>
<li>只能通过类进行修改</li>
<li>对象修改 仅仅是添加了一个对象属性，不是真正的修改</li>
</ul>
</li>
<li><strong>实例属性</strong>是在init方法里 定义的属性<ul>
<li>只能通过对象访问，修改</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="comment"># 类属性</span></span><br><span class="line">    type = <span class="string">"黄种人"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        <span class="comment"># 实例(对象)属性</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"><span class="comment"># ------- 类属性操作 -------</span></span><br><span class="line"><span class="comment"># 访问类属性</span></span><br><span class="line">print(Person.type) <span class="comment"># 黄种人</span></span><br><span class="line"><span class="comment"># 不能使用类访问 对象属性</span></span><br><span class="line"><span class="comment"># print(Person.age)</span></span><br><span class="line"><span class="comment"># AttributeError: type object 'Person' has no attribute 'age'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改类属性</span></span><br><span class="line">Person.type = <span class="string">"白种人"</span></span><br><span class="line">print(Person.type)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------- 对象属性操作 -------</span></span><br><span class="line">person = Person(<span class="string">"zhangsan"</span>, <span class="number">20</span>)</span><br><span class="line">print(person.name, person.age)</span><br><span class="line">print(person.type)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：类属性的操作由类完成，对象属性的操作由实例完成，对象可以访问类属性，不能修改</p>
<p>同样，可以定义 私有类属性</p>
</blockquote>
<h2 id="类方法和静态方法"><a href="#类方法和静态方法" class="headerlink" title="类方法和静态方法"></a>类方法和静态方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 私有类属性</span></span><br><span class="line">    __type = <span class="string">'黄种人'</span></span><br><span class="line">    <span class="comment"># 定义对象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"我是人类_对象方法"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义类方法：cls表示当前类</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_info</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(cls)</span><br><span class="line">        print(<span class="string">"class method called"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义静态方法：与当前对象、当前类都没有关系。不会使用cls和self</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_msg</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"static method called"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类方法可以修改类属性</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_type</span><span class="params">(cls, type)</span>:</span></span><br><span class="line">        cls.__type = type</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_type</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls.__type</span><br><span class="line">    <span class="comment"># ------ 对象方法是最通用的方法，可以修改对象属性 和 类属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">instance_set_type</span><span class="params">(self, type)</span>:</span></span><br><span class="line">        <span class="comment"># 对象方法修改类属性，需要获取对象所对应的类</span></span><br><span class="line">        self.__class__.__type = type</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">instance_get_type</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__class__.__type</span><br><span class="line">p = Person()</span><br><span class="line">p.show()</span><br><span class="line">p.show_info()</span><br><span class="line">p.show_msg()</span><br><span class="line">p.set_type(<span class="string">"白种人"</span>)</span><br><span class="line">print(p.get_type())</span><br><span class="line"></span><br><span class="line">p.instance_set_type(<span class="string">"黑种人"</span>)</span><br><span class="line">print(p.instance_get_type())</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>对象方法</th>
<th>类方法</th>
<th>静态方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>对象</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>类</td>
<td>传入实例</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>对象属性</th>
<th>类属性</th>
</tr>
</thead>
<tbody>
<tr>
<td>对象方法</td>
<td>√</td>
<td>obj.__class__</td>
</tr>
<tr>
<td>类方法</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>静态方法</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
</div>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>严格意义上讲，Python中并无多态，在其他面向对象语言中，多态要关心类型……</p>
<ul>
<li>关注的是 <strong>同一个方法</strong>，但是会出现不同的表现形式</li>
<li>Python中不需要关心类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Text</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"显示文字"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"显示图像"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Video</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"显示视频"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_data</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="comment"># 多态：关心的是同一个方法，会出现不同的表现形式</span></span><br><span class="line">    <span class="comment"># Python中多态：只关心对象的方法，不关心对象的类型</span></span><br><span class="line">    data.show()</span><br><span class="line">    <span class="comment"># 传入的对象必须都有show方法才行！</span></span><br><span class="line"></span><br><span class="line">txt = Text()</span><br><span class="line">img = Image()</span><br><span class="line">video = Video()</span><br><span class="line"></span><br><span class="line">show_data(txt)</span><br><span class="line">show_data(img)</span><br><span class="line">show_data(video)</span><br></pre></td></tr></table></figure>
<h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><ul>
<li>在APP中不管创建多少次对象，只有一个实例对象</li>
</ul>
<p>在传统方式下，创建多个对象，他们的地址不一样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"创建对象"</span>)</span><br><span class="line">        <span class="keyword">return</span> object.__new__(cls)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"初始化对象"</span>)</span><br><span class="line"></span><br><span class="line">stu1 = Student()</span><br><span class="line">stu2 = Student()</span><br><span class="line"><span class="comment"># 两个对象的地址不一样</span></span><br><span class="line">print(stu1, stu2)</span><br></pre></td></tr></table></figure>
<p>单例要求，不管创建多少次对象，这些对象的内存地址都一样，需要在new方法中控制：</p>
<p>如果对象已经存在，就直接返回之前创建的对象；</p>
<p>如果要记录这个对象，必须是类属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 私有类属性</span></span><br><span class="line">    __instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls.__instance:</span><br><span class="line">            print(<span class="string">"创建对象"</span>)</span><br><span class="line">            <span class="comment"># 把创建的对象 给 类属性</span></span><br><span class="line">            cls.__instance =  object.__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        print(<span class="string">"初始化对象"</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">stu1 = Student(<span class="string">"zs"</span>, <span class="number">20</span>)</span><br><span class="line">print(stu1.__dict__) <span class="comment"># &#123;'name': 'zs', 'age': 20&#125;</span></span><br><span class="line">stu2 = Student(<span class="string">'ss'</span>, <span class="number">15</span>)</span><br><span class="line">print(stu1.__dict__) <span class="comment"># &#123;'name': 'ss', 'age': 15&#125;</span></span><br><span class="line">print(stu2.__dict__) <span class="comment"># &#123;'name': 'ss', 'age': 15&#125;</span></span><br><span class="line"><span class="comment"># 两个对象的地址一样</span></span><br><span class="line">print(stu1, stu2)</span><br></pre></td></tr></table></figure>
<h2 id="面向对象高级编程"><a href="#面向对象高级编程" class="headerlink" title="面向对象高级编程"></a>面向对象高级编程</h2><h3 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a>__slots__</h3><ul>
<li>指明创建对象的时候不能再添加其他属性，只能是指定的属性</li>
<li>好处：可以让对象的属性固定</li>
<li>注意：加上后必须在init函数中加入相应初始化操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">"name"</span>, <span class="string">"age"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">stu = Student(<span class="string">"zhangsan"</span>, <span class="number">18</span>)</span><br><span class="line"><span class="comment"># stu.sex = '女'</span></span><br><span class="line"><span class="comment"># AttributeError: 'Student' object has no attribute 'sex'</span></span><br><span class="line">print(stu.name, stu.age)</span><br><span class="line">stu.name = <span class="string">'lisi'</span></span><br><span class="line">print(stu.name, stu.age)</span><br></pre></td></tr></table></figure>
<h3 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h3><p>先观察下列代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># __slots__ = ("name", "age")</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__score = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self, score)</span>:</span></span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__score</span><br><span class="line"></span><br><span class="line">stu = Student()</span><br><span class="line">score = stu.get_score()</span><br><span class="line">print(score) <span class="comment"># 100</span></span><br><span class="line"></span><br><span class="line">stu.set_score(<span class="number">99</span>)</span><br><span class="line">score = stu.get_score()</span><br><span class="line">print(score) <span class="comment"># 99</span></span><br></pre></td></tr></table></figure>
<p>现在有一种需求，在设置值的时候不想通过函数的方式进行传值，而是像类似于下面的操作</p>
<p><code>stu.set_score = 99</code></p>
<p>可以进行如下操作来实现：</p>
<ol>
<li>在获取值的方法前加入 @property</li>
<li>在设置值的方法前 @get_method.setter</li>
</ol>
<p>这样操作后，被处理后的方法就变成了属性</p>
<p>此时不能用函数的方法进行设置和获取，会报错 <code>TypeError: ‘int’ object is not callable</code> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__score = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @get_score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self, score)</span>:</span></span><br><span class="line">        self.__score = score</span><br><span class="line">stu = Student()</span><br><span class="line">score = stu.get_score</span><br><span class="line">print(score)</span><br><span class="line"></span><br><span class="line">stu.set_score = <span class="number">99</span></span><br><span class="line">score = stu.get_score</span><br><span class="line">print(score)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习笔记1-Python基础</title>
    <url>/2019/04/28/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-Python%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="第一个Python程序"><a href="#第一个Python程序" class="headerlink" title="第一个Python程序"></a>第一个Python程序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"hello world"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h2><blockquote>
<p>格式：变量名 = 数据</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">score = <span class="number">100</span></span><br><span class="line">name = <span class="string">"张三"</span></span><br><span class="line">pi = <span class="number">3.14</span></span><br><span class="line">print(score)</span><br><span class="line"><span class="comment"># 在Python中不需要指定数据类型，会根据数据自动推导出数据类型</span></span><br><span class="line">is_ok = <span class="literal">True</span></span><br><span class="line"><span class="comment"># 通过type查看变量类型</span></span><br><span class="line">print(type(score))</span><br><span class="line">print(type(name))</span><br><span class="line">print(type(pi))</span><br><span class="line">print(type(is_ok))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否是指定数据类型</span></span><br><span class="line">isinstance(obj, type)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>常用数据类型：int str float bool list tuple dict set</p>
</blockquote>
<h2 id="变量的命名规则"><a href="#变量的命名规则" class="headerlink" title="变量的命名规则"></a>变量的命名规则</h2><h3 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h3><blockquote>
<p>字母、数字、下划线组成，但不能以数字开头</p>
</blockquote>
<h3 id="变量命名方式"><a href="#变量命名方式" class="headerlink" title="变量命名方式"></a>变量命名方式</h3><ul>
<li><p>驼峰命名法</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 小驼峰</span></span><br><span class="line">myName = <span class="string">"李四"</span></span><br><span class="line"><span class="comment"># 大驼峰</span></span><br><span class="line">MyName = <span class="string">"王五"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下划线命名法 <strong>（推荐使用）</strong></p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_name = <span class="string">"赵六"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>关键字在Python中具有特殊功能标识符，关键字不能作为变量名使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line">kw = keyword.kwlist</span><br><span class="line">print(kw)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"> 'False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await',</span></span><br><span class="line"><span class="string"> 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except',</span></span><br><span class="line"><span class="string"> 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda',</span></span><br><span class="line"><span class="string"> 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>对代码的解释和说明，可以提供代码的可读性</p>
<h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>以#开头</p>
<h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>用三个双引号 or 三个单引号 包围起来<br>快捷键：Ctrl + /</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单行注释</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">多行注释1</span></span><br><span class="line"><span class="string">多行注释1</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">多行注释2</span></span><br><span class="line"><span class="string">多行注释2</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><ul>
<li>int()<ul>
<li>float -&gt; int 取整数部分</li>
</ul>
</li>
<li><p>float()</p>
</li>
<li><p>str()</p>
</li>
<li><p>evel() 获取字符串 <strong>原始数据</strong></p>
<ul>
<li>evel(‘abc’) 会报错 NameError: name ‘abc’ is not defined.</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num1 = <span class="number">10</span></span><br><span class="line">my_str = <span class="string">"10"</span></span><br><span class="line"><span class="comment"># 把字符串转成 int 类型</span></span><br><span class="line">num2 = int(my_str)</span><br><span class="line">print(type(num2))</span><br><span class="line"><span class="comment"># 目前类型统一可以进行计算</span></span><br><span class="line">result = num1 + num2</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">my_float_str = <span class="string">"3.14"</span></span><br><span class="line">num3 = float(my_float_str)</span><br><span class="line">print(num3)</span><br><span class="line">print(type(num3))</span><br><span class="line"></span><br><span class="line"><span class="comment"># int类型和float类型计算 会把int转成float</span></span><br><span class="line">result = num1 + num3</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">num4 = <span class="number">4.55</span></span><br><span class="line"><span class="comment"># 注意：只取整数部分</span></span><br><span class="line">num5 = int(num4)</span><br><span class="line">print(num5)</span><br><span class="line"></span><br><span class="line">print(type(str(num4)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># eval: 获取字符串原始数据</span></span><br><span class="line"><span class="comment"># my_str = "5.15"</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">my_str = "abc"</span></span><br><span class="line"><span class="string">NameError: name 'abc' is not defined</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">my_str = <span class="string">'[1,3,5]'</span></span><br><span class="line">value = eval(my_str)</span><br><span class="line">print((value))</span><br><span class="line">print(type(value))</span><br></pre></td></tr></table></figure>
<h2 id="输出和输入"><a href="#输出和输入" class="headerlink" title="输出和输入"></a>输出和输入</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>print函数定义如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print</span><span class="params">(self, *args, sep=<span class="string">' '</span>, end=<span class="string">'\n'</span>, file=None)</span>:</span> <span class="comment"># known special case of print</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Prints the values to a stream, or to sys.stdout by default.</span></span><br><span class="line"><span class="string">    Optional keyword arguments:</span></span><br><span class="line"><span class="string">    file:  a file-like object (stream); defaults to the current sys.stdout.</span></span><br><span class="line"><span class="string">    sep:   string inserted between values, default a space.</span></span><br><span class="line"><span class="string">    end:   string appended after the last value, default a newline.</span></span><br><span class="line"><span class="string">    flush: whether to forcibly flush the stream.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>*args</code> 表示不定长的参数</li>
<li>seq = ‘ ‘ 默认用空格符间隔，可以修改</li>
<li>end=’\n 同理</li>
</ul>
<p>测试代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'hello world'</span>)</span><br><span class="line">my_str1 = <span class="string">'hello'</span></span><br><span class="line">my_str2 = <span class="string">'world'</span></span><br><span class="line"><span class="comment"># 输出多个参数之间 默认使用 空格进行分割</span></span><br><span class="line">print(my_str1, my_str2)</span><br><span class="line"><span class="comment"># 修改输出的分隔符</span></span><br><span class="line">print(my_str1, my_str2, sep =<span class="string">'&amp;'</span>)</span><br><span class="line"><span class="comment"># 修改为不换行</span></span><br><span class="line">print(<span class="string">"hello"</span>, end=<span class="string">''</span>)</span><br><span class="line">print(<span class="string">'你好'</span>)</span><br><span class="line">print(<span class="string">"哈哈\n嘻嘻"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>input函数定义如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print</span><span class="params">(self, *args, sep=<span class="string">' '</span>, end=<span class="string">'\n'</span>, file=None)</span>:</span> <span class="comment"># known special case of print</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Prints the values to a stream, or to sys.stdout by default.</span></span><br><span class="line"><span class="string">    Optional keyword arguments:</span></span><br><span class="line"><span class="string">    file:  a file-like object (stream); defaults to the current sys.stdout.</span></span><br><span class="line"><span class="string">    sep:   string inserted between values, default a space.</span></span><br><span class="line"><span class="string">    end:   string appended after the last value, default a newline.</span></span><br><span class="line"><span class="string">    flush: whether to forcibly flush the stream.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p> <code>input()</code> 返回的数据类型都是str</p>
<blockquote>
<p>注：Python2中使用 <code>raw_print</code></p>
</blockquote>
<h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><h3 id="if-else结构"><a href="#if-else结构" class="headerlink" title="if-else结构"></a>if-else结构</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = int(input(<span class="string">'请输入您的年龄：'</span>))</span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">'adult'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'not adult'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="if-elif-else结构"><a href="#if-elif-else结构" class="headerlink" title="if-elif-else结构"></a>if-elif-else结构</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = int(input(<span class="string">'请输入您的年龄：'</span>))</span><br><span class="line"><span class="keyword">if</span> <span class="number">15</span> &lt;= age &lt;= <span class="number">17</span>:</span><br><span class="line">    print(<span class="string">'1'</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt; <span class="number">17</span> <span class="keyword">and</span> age &lt;= <span class="number">40</span>:</span><br><span class="line">    print(<span class="string">'2'</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt; <span class="number">40</span> <span class="keyword">and</span> age &lt; <span class="number">80</span>:</span><br><span class="line">    print(<span class="string">'3'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'unknown'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="可以判断的类型"><a href="#可以判断的类型" class="headerlink" title="可以判断的类型"></a>可以判断的类型</h3><ul>
<li>bool类型</li>
<li>数字类型——非0即真</li>
<li>容器类型——有数据即真，无数据为假</li>
<li>None空值<ul>
<li>None —&gt; 条件不成立</li>
<li>not None —&gt; 条件成立</li>
</ul>
</li>
</ul>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><ul>
<li>== , &gt;= , &gt; , &lt; , &lt;= , !=</li>
<li>运算结果返回bool类型</li>
</ul>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><ul>
<li>and , or , not</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">score = <span class="number">90</span></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span> <span class="keyword">and</span> score &lt;= <span class="number">100</span>:</span><br><span class="line">    print(<span class="string">'优秀'</span>)</span><br><span class="line">num1 = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> num1 == <span class="number">1</span> <span class="keyword">or</span> num1 == <span class="number">2</span>:</span><br><span class="line">    print(<span class="string">'Nice'</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="number">1</span> == <span class="number">2</span>:</span><br><span class="line">    print(<span class="string">'条件成立'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="字符串常见操作"><a href="#字符串常见操作" class="headerlink" title="字符串常见操作"></a>字符串常见操作</h2><ul>
<li><p>根据子串查找下标</p>
<ul>
<li><code>str.find()</code> 如果没有找到就返回-1</li>
<li><code>str.index()</code>如果没有找到抛出异常</li>
</ul>
</li>
<li><p>统计字符串个数</p>
<ul>
<li><code>len(str)</code></li>
<li><code>str.count(substr)</code></li>
</ul>
</li>
<li>替换指定数据<ul>
<li><code>str.replace(old,new[,count])</code></li>
</ul>
</li>
<li>分割数据<ul>
<li><code>str.split()</code></li>
</ul>
</li>
<li>判断是否以指定数据开头<ul>
<li><code>str.startswith()</code></li>
</ul>
</li>
<li>把字符串以指定子串分割成三部分<ul>
<li><code>str.partition(sep)</code></li>
</ul>
</li>
<li>根据指定字符串拼接数据<ul>
<li><code>flag_str.join()</code></li>
<li>注：前提是最终的数据是字符串<code>“123” [‘1’,’2’]</code>等</li>
</ul>
</li>
<li>去除空格<ul>
<li><code>str.strip()</code> 去除两边空格</li>
<li><code>str.lstrip()</code> 去除左边空格</li>
<li><code>str.rstrip()</code> 去除右边空格</li>
</ul>
</li>
<li>去除指定数据<ul>
<li><code>str.strip(sub)</code> 去除两边</li>
<li><code>str.lstrip(sub)</code> 去除左边</li>
<li><code>str.rstrip(sub)</code> 去除右边</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str = <span class="string">'hello'</span></span><br><span class="line">print(my_str.index(<span class="string">'e'</span>)) <span class="comment"># 1</span></span><br><span class="line">print(my_str.find(<span class="string">'h'</span>)) <span class="comment"># 0</span></span><br><span class="line"><span class="comment"># print(my_str.index('f')) # Error</span></span><br><span class="line">print(my_str.find(<span class="string">'x'</span>)) <span class="comment"># -1</span></span><br><span class="line">print(len(my_str)) <span class="comment"># 5</span></span><br><span class="line">print(my_str.count(<span class="string">'l'</span>)) <span class="comment"># 2</span></span><br><span class="line">print(my_str.replace(<span class="string">'l'</span>,<span class="string">'x'</span>)) <span class="comment"># hexxo</span></span><br><span class="line"></span><br><span class="line">my_str = <span class="string">'百度,阿里,华为'</span></span><br><span class="line">print(my_str.split(<span class="string">','</span>)) <span class="comment"># ['百度', '阿里', '华为']</span></span><br><span class="line"></span><br><span class="line">my_url = <span class="string">"https://www.baidu.com"</span></span><br><span class="line">print(my_url.startswith(<span class="string">'https'</span>)) <span class="comment"># True</span></span><br><span class="line">print(my_url.endswith(<span class="string">'com'</span>)) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">my_str = <span class="string">'aaabbcccc'</span></span><br><span class="line">print(my_str.partition(<span class="string">'bb'</span>)) <span class="comment"># ('aaa', 'bb', 'cccc')</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'-'</span>.join(<span class="string">'abc'</span>)) <span class="comment"># a-b-c</span></span><br><span class="line">print(<span class="string">'-'</span>.join([<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>])) <span class="comment"># 1-2-3</span></span><br><span class="line">print(<span class="string">'-'</span>.join((<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>)))</span><br><span class="line"></span><br><span class="line">print(<span class="string">' hello '</span>.strip())</span><br><span class="line">print(<span class="string">' hello '</span>.lstrip())</span><br><span class="line"></span><br><span class="line">print(<span class="string">'abcdcba'</span>.strip(<span class="string">'a'</span>))     <span class="comment"># bcdcb</span></span><br><span class="line">print(<span class="string">'abcdcba'</span>.lstrip(<span class="string">'a'</span>))    <span class="comment"># bcdcba</span></span><br></pre></td></tr></table></figure>
<h2 id="列表与元组"><a href="#列表与元组" class="headerlink" title="列表与元组"></a>列表与元组</h2><h3 id="列表（有序）"><a href="#列表（有序）" class="headerlink" title="列表（有序）"></a>列表（有序）</h3><ul>
<li>定义：以中括号表现形式的数据集合</li>
<li><p>列表中可以放入任意类型的数据</p>
</li>
<li><p>下标：一个编号，根据编号找到数据</p>
<ul>
<li>正数下标：默认从0开始，表示第1个元素</li>
<li>负数下标：-1表示 倒数 第1个元素</li>
</ul>
</li>
<li><p>访问元素可以直接用<code>varname[index]</code></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">1.22</span>, <span class="string">"abc"</span>, <span class="literal">True</span>]</span><br><span class="line">print(my_list, type(my_list)) <span class="comment"># [1, 1.22, 'abc', True] &lt;class 'list'&gt;</span></span><br><span class="line"><span class="comment"># 根据下标获取列表数据</span></span><br><span class="line">print(my_list[<span class="number">0</span>]) <span class="comment"># 1</span></span><br><span class="line">print(my_list[<span class="number">-2</span>]) <span class="comment"># abc</span></span><br></pre></td></tr></table></figure>
<ul>
<li>添加操作<ul>
<li><code>append()</code> <ul>
<li>向列表中追加一个指定数据</li>
</ul>
</li>
<li><code>insert(index, object)</code><ul>
<li>在index位置插入指定数据</li>
</ul>
</li>
<li><code>extend(list)</code></li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.1 向列表中追加一个指定数据</span></span><br><span class="line">my_list.append(<span class="number">1</span>)</span><br><span class="line">my_list.append(<span class="string">"大家好"</span>)</span><br><span class="line">print(my_list) <span class="comment"># [1, '大家好']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.2 插入指定数据</span></span><br><span class="line">my_list.insert(<span class="number">1</span>, <span class="string">'abc'</span>)</span><br><span class="line">print(my_list) <span class="comment"># [1, 'abc', '大家好']</span></span><br><span class="line"></span><br><span class="line">my_list1 = [<span class="string">"西瓜"</span>, <span class="string">"草莓"</span>, <span class="string">"芒果"</span>]</span><br><span class="line"><span class="comment"># my_list.append(my_list1)</span></span><br><span class="line"><span class="comment"># print(my_list)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.3 extend 扩展一组数据</span></span><br><span class="line">my_list.extend(my_list1) <span class="comment"># [1, 'abc', '大家好', '西瓜', '草莓', '芒果']</span></span><br><span class="line">print(my_list)</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>修改操作</p>
<ul>
<li>访问下标直接改</li>
</ul>
</li>
<li><p>删除操作</p>
<ul>
<li><code>remove(obj)</code> 删除指定数据</li>
<li><code>del list[index]</code><ul>
<li>用del关键字删除指定下标的元素</li>
<li>如果不合法则抛出异常</li>
</ul>
</li>
<li><p><code>pop()</code></p>
<ul>
<li>默认删除最后一个元素</li>
<li>同时返回被删除的元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改数据</span></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="string">'abc'</span>, <span class="string">'大家好'</span>, <span class="string">'西瓜'</span>, <span class="string">'草莓'</span>, <span class="string">'芒果'</span>]</span><br><span class="line">my_list[<span class="number">0</span>] = <span class="string">'葡萄'</span></span><br><span class="line">my_list[<span class="number">-1</span>] = <span class="string">'桃子'</span></span><br><span class="line">print(my_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除数据</span></span><br><span class="line">my_list = [<span class="string">'葡萄'</span>, <span class="string">'abc'</span>, <span class="string">'大家好'</span>, <span class="string">'西瓜'</span>, <span class="string">'草莓'</span>, <span class="string">'桃子'</span>]</span><br><span class="line">my_list.remove(<span class="string">'abc'</span>)</span><br><span class="line">print(my_list)</span><br><span class="line"><span class="keyword">del</span> my_list[<span class="number">-1</span>]</span><br><span class="line">print(my_list)</span><br><span class="line">print(my_list.pop(), my_list)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>查询操作</p>
<ul>
<li><code>object in list</code></li>
<li><code>object not in list</code><ul>
<li>返回<code>True/False</code></li>
</ul>
</li>
<li><code>list.index(obj)</code> 根据数据查询指定下标<ul>
<li>返回索引值</li>
<li>不存在则抛出异常</li>
</ul>
</li>
<li><p><code>list.count(obj)</code> 根据指定数据获取 数据 在列表中的个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找</span></span><br><span class="line">my_list = [<span class="string">'大家好'</span>, <span class="string">'葡萄'</span>, <span class="string">'葡萄'</span>, <span class="string">'西瓜'</span>, <span class="string">'草莓'</span>]</span><br><span class="line">print(<span class="string">"西瓜"</span> <span class="keyword">in</span> my_list)</span><br><span class="line">print(<span class="string">"相加"</span> <span class="keyword">not</span> <span class="keyword">in</span> my_list)</span><br><span class="line">print(my_list.index(<span class="string">"葡萄"</span>)) <span class="comment"># 1</span></span><br><span class="line"><span class="comment"># print(my_list.index("111"))</span></span><br><span class="line">print(my_list.count(<span class="string">"葡萄"</span>)) <span class="comment"># 2</span></span><br><span class="line">print(my_list.count(<span class="string">"11"</span>)) <span class="comment"># 0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><ul>
<li><p>定义： 以小括号表现形式的数据集合</p>
<ul>
<li>坑点：如果仅仅有1个元素需要在其后加逗号<code>(5,)</code>不然括号会被忽略</li>
</ul>
</li>
<li>注意：<ul>
<li>元组可以存放任意数据</li>
<li>元组指定下标获取数据，不能对元组进行数据的修改</li>
<li>如果元组数据为列表，可对列表操作进行数据修改</li>
</ul>
</li>
<li><p>查询操作同列表</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_tuple = (<span class="number">1</span>, <span class="number">4</span>, <span class="string">'abc'</span>, <span class="literal">True</span>, <span class="number">1.2</span>)</span><br><span class="line">print(my_tuple)</span><br><span class="line">print(my_tuple[<span class="number">2</span>], my_tuple[<span class="number">-1</span>])</span><br><span class="line"><span class="comment"># del my_tuple[2]</span></span><br><span class="line"><span class="comment"># my_tuple[0] = 2</span></span><br><span class="line"></span><br><span class="line">my_tuple = (<span class="number">1</span>, [<span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment"># 直接根据下标修改元组中的数据。不支持</span></span><br><span class="line"><span class="comment"># my_tuple[1] = [2, 4]</span></span><br><span class="line"><span class="comment"># 取到元素再修改</span></span><br><span class="line">my_tuple[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">print(my_tuple) <span class="comment"># (1, [2, 5])</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="字典（无序）"><a href="#字典（无序）" class="headerlink" title="字典（无序）"></a>字典（无序）</h2><ul>
<li><p>定义：以大括号表现形式的键值对数据的集合，比如<code>{‘name’:’zhangsan’, ‘age’:18}</code></p>
</li>
<li><p>注意：</p>
<ul>
<li>key 一般都是字符串，只能是不可变类型(数字、字符串、元组)，不能使用可变类型：[],{}</li>
<li>通过key获取对应value，key在字典里边唯一</li>
</ul>
</li>
</ul>
<ul>
<li>字典是无序的，定义的数据顺序和输出顺序 不一致</li>
</ul>
<ul>
<li><p>取值操作</p>
<ul>
<li><code>dict[key]</code><ul>
<li>如果key不存在则抛出异常</li>
</ul>
</li>
<li><p><code>dict.get(key, default)</code></p>
<ul>
<li>如果key不存在，默认返回 <code><class 'nonetype'></class></code> None , 也可设置默认返回的值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict = &#123;<span class="string">'name'</span>:<span class="string">'zhangsan'</span>, <span class="string">'age'</span>:<span class="number">18</span>&#125;</span><br><span class="line">print(my_dict, type(my_dict))</span><br><span class="line">print(my_dict[<span class="string">'name'</span>])</span><br><span class="line">print(my_dict.get(<span class="string">'age'</span>))</span><br><span class="line"><span class="comment"># my_dict['sex']</span></span><br><span class="line">print(my_dict.get(<span class="string">'sex'</span>, <span class="string">"男"</span>))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>添加/删除操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义空字典</span></span><br><span class="line">my_dict = &#123;&#125;</span><br><span class="line"><span class="comment"># 添加键值对，key不在字典里则添加</span></span><br><span class="line">my_dict[<span class="string">'name'</span>] = <span class="string">'zhangsan'</span></span><br><span class="line">my_dict[<span class="string">'age'</span>] = <span class="number">18</span></span><br><span class="line">my_dict[<span class="string">'sex'</span>] = <span class="string">'Male'</span></span><br><span class="line">my_dict[<span class="string">'address'</span>] = <span class="string">'Beijing'</span></span><br><span class="line">print(my_dict)</span><br><span class="line"><span class="comment"># 修改键值对，key存在就是修改</span></span><br><span class="line">my_dict[<span class="string">'address'</span>] = <span class="string">'Shanghai'</span></span><br><span class="line">print(my_dict)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除操作</p>
<ul>
<li><p><code>del dict[key]</code></p>
</li>
<li><p><code>dict.popitem()</code> 随机删除键值对，返回key和value的元组</p>
</li>
<li><p><code>dict.pop(key)</code> 删除指定key的键值对，返回key和value</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict = &#123;<span class="string">'name'</span>: <span class="string">'zhangsan'</span>, <span class="string">'sex'</span>: <span class="string">'Male'</span>, <span class="string">'address'</span>: <span class="string">'Shanghai'</span>&#125;</span><br><span class="line"><span class="comment"># 随机删除键值对，返回&lt;class 'tuple'&gt; key和value</span></span><br><span class="line">value = my_dict.popitem()</span><br><span class="line">print(value, type(value))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>查操作</p>
<ul>
<li><code>key in dict</code></li>
<li><code>key in dict.keys()</code></li>
<li><code>value in dict.values()</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict = &#123;<span class="string">'name'</span>: <span class="string">'zhangsan'</span>, <span class="string">'age'</span>: <span class="number">18</span>, <span class="string">'sex'</span>: <span class="string">'Male'</span>, <span class="string">'address'</span>: <span class="string">'Shanghai'</span>&#125;</span><br><span class="line">print(my_dict.keys(), type(my_dict.keys()))</span><br><span class="line"><span class="comment"># dict_keys(['name', 'age', 'sex', 'address']) &lt;class 'dict_keys'&gt;</span></span><br><span class="line">print(my_dict.values(), type(my_dict.values()))</span><br><span class="line"><span class="comment"># dict_values(['zhangsan', 18, 'Male', 'Shanghai']) &lt;class 'dict_values'&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="循环-for、while"><a href="#循环-for、while" class="headerlink" title="循环(for、while)"></a>循环(for、while)</h2><ul>
<li><p>定义：根据条件循环执行某种操作</p>
</li>
<li><p>基本用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> num &lt;= <span class="number">5</span>:</span><br><span class="line">    print(num)</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">print(<span class="string">'--------------'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># for循环一般结合range使用</span></span><br><span class="line"><span class="comment"># range(起始,结束,步长)</span></span><br><span class="line"><span class="comment"># range(1,5) 实际上是[1,5) 不包含5,步长=1</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">100</span>, <span class="number">10</span>):</span><br><span class="line">    print(value)</span><br><span class="line">print(<span class="string">'--------------'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># range(5) 起始=0,结束=5,步长=1</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    print(value)</span><br></pre></td></tr></table></figure>
</li>
<li><p>跟else结合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">5</span></span><br><span class="line"><span class="keyword">while</span> num &gt;= <span class="number">1</span>:</span><br><span class="line">    print(num)</span><br><span class="line">    num -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"循环执行结束"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">if</span> value == <span class="number">2</span> :</span><br><span class="line">        print(<span class="string">'ok'</span>)</span><br><span class="line">    print(value)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'循环结束'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>continue和break</p>
<ul>
<li>不能单独使用，只能在循环语句中使用</li>
<li>break的时候，else语句也不执行，强行退出循环体</li>
</ul>
</li>
<li><p>else和break实例(注意else所在位置，不能往后缩进)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = input(<span class="string">"请输入你的姓名："</span>)</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">"张三"</span>, <span class="string">"李四"</span>]:</span><br><span class="line">    <span class="keyword">if</span> value == name:</span><br><span class="line">        print(value)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"没有找到这个人"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>for的应用——获取容器类型(字符串、列表、元组、字典、set)中每一个数据</p>
<ul>
<li>遍历字符串、列表、元组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仅获取value(set可用)</span></span><br><span class="line">my_str = <span class="string">"abc"</span></span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> my_str:</span><br><span class="line">    print(val)</span><br><span class="line"></span><br><span class="line">my_list = [<span class="string">"apple"</span>, <span class="string">"pear"</span>, <span class="string">"banana"</span>]</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> my_list:</span><br><span class="line">    print(val)</span><br><span class="line">print(<span class="string">"------------"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时获取index value</span></span><br><span class="line">my_list = enumerate([<span class="string">"apple"</span>, <span class="string">"pear"</span>, <span class="string">"banana"</span>])</span><br><span class="line">print(my_list)</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> my_list:</span><br><span class="line">    <span class="comment"># 此时每个val为元组</span></span><br><span class="line">    print(val[<span class="number">0</span>], val[<span class="number">1</span>])</span><br><span class="line">print(<span class="string">"------------"</span>)</span><br><span class="line"></span><br><span class="line">my_list = enumerate([<span class="string">"apple"</span>, <span class="string">"pear"</span>, <span class="string">"banana"</span>])</span><br><span class="line"><span class="comment"># index, val获取的是 元组中的每一个值，就是拆包</span></span><br><span class="line"><span class="keyword">for</span> index, val <span class="keyword">in</span> my_list:</span><br><span class="line">    print(index, val)</span><br></pre></td></tr></table></figure>
<ul>
<li>遍历 字典</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict = &#123;<span class="string">'name'</span>: <span class="string">'zhangsan'</span>, <span class="string">'age'</span>: <span class="number">18</span>, <span class="string">'sex'</span>: <span class="string">'Male'</span>, <span class="string">'address'</span>: <span class="string">'Shanghai'</span>&#125;</span><br><span class="line"><span class="comment"># 遍历 key</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> my_dict:</span><br><span class="line">    print(key)</span><br><span class="line">print(<span class="string">'----------'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历 value</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> my_dict.values():</span><br><span class="line">    print(value)</span><br><span class="line">print(<span class="string">'----------'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时取到key value</span></span><br><span class="line"><span class="comment"># for key, value in my_dict:  # 错误写法</span></span><br><span class="line"><span class="comment">#     print(key, value)</span></span><br><span class="line">print(my_dict.items()) <span class="comment"># 每一项组成的元组的列表</span></span><br><span class="line">print(<span class="string">'----------'</span>)</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> my_dict.items():</span><br><span class="line">    print(key, value)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul>
<li>定义：以大括号表现形式的数据集合，集合里边不能有重复数据，集合也是无序</li>
<li><p>注意：</p>
<ul>
<li>不能根据下标获取和修改数据，可以添加和删除</li>
<li>定义空的集合不能使用<code>{}</code> 会识别为dict，正确操作：<code>my_set = set()</code></li>
</ul>
</li>
<li><p>常见操作：</p>
<ul>
<li><code>add(obj)</code> 添加数据</li>
<li><code>remove(obj)</code> / <code>discard(obj)</code> 删除数据<ul>
<li>remove不存在会抛出异常</li>
<li>discard不存在会忽略，不会崩溃</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_set = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="string">'abc'</span>, <span class="string">'hello'</span>&#125;</span><br><span class="line">print(my_set, type(my_set))</span><br><span class="line">my_set.add(<span class="number">5</span>)</span><br><span class="line">print(my_set)</span><br><span class="line"></span><br><span class="line"><span class="comment"># my_set.remove('abcd')</span></span><br><span class="line">print(my_set.discard(<span class="string">'abcd'</span>)) <span class="comment"># None</span></span><br><span class="line">print(my_set.discard(<span class="number">5</span>)) <span class="comment"># None</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>集合可以对容器类型数据去重</p>
<ul>
<li><code>set(list)</code></li>
</ul>
</li>
</ul>
<h2 id="补充-元组、列表、集合互相转换"><a href="#补充-元组、列表、集合互相转换" class="headerlink" title="补充- 元组、列表、集合互相转换"></a>补充- 元组、列表、集合互相转换</h2><ul>
<li>set()</li>
<li>tuple()</li>
<li>list()</li>
</ul>
<blockquote>
<p>直接调用相关的 函数 即可转换。注意转为set的时候自动去重</p>
</blockquote>
<h2 id="拆包"><a href="#拆包" class="headerlink" title="拆包"></a>拆包</h2><ul>
<li>通俗理解：把容器类型（字符串、列表、元组、字典、集合）中每一个数据使用不同的变量进行保存</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str = <span class="string">"abc"</span></span><br><span class="line">var1, var2, var3 = my_str</span><br><span class="line">print(var1, var2, var3)</span><br><span class="line"></span><br><span class="line">my_dict = &#123;<span class="string">'name'</span>: <span class="string">'zhangsan'</span>, <span class="string">'age'</span>: <span class="number">18</span>, <span class="string">'sex'</span>: <span class="string">'Male'</span>, <span class="string">'address'</span>: <span class="string">'Shanghai'</span>&#125;</span><br><span class="line"><span class="comment"># key1, key2 = my_dict</span></span><br><span class="line"><span class="comment"># 变量个数要和容器的个数一致</span></span><br><span class="line">key1, key2, key3, key4 = my_dict</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的介绍"><a href="#函数的介绍" class="headerlink" title="函数的介绍"></a>函数的介绍</h3><ul>
<li>通俗理解：某一个功能的代码实现</li>
<li>目的：代码复用，降低代码冗余</li>
</ul>
<h3 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义函数,不自动调用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"helloWorld"</span>)</span><br><span class="line">    print(<span class="string">"helloWorld"</span>)</span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">fun()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义含参数的 函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(name, age)</span>:</span></span><br><span class="line">    print(<span class="string">"My name is %s, %d years old."</span> % (name, age))</span><br><span class="line">show(<span class="string">'Amy'</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<h3 id="函数的四种类型"><a href="#函数的四种类型" class="headerlink" title="函数的四种类型"></a>函数的四种类型</h3><ul>
<li>无参数、无返回值</li>
<li>有参数、无返回值</li>
<li>无参数、有返回值</li>
<li>有参数、有返回值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun3</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"类型3函数"</span></span><br><span class="line">print(fun3())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun4</span><span class="params">(name, age)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"My name is %s, %d years old."</span> % (name, age)</span><br><span class="line">print(fun4(<span class="string">'xiaohuihui'</span>, <span class="number">20</span>))</span><br></pre></td></tr></table></figure>
<h3 id="函数的调用顺序"><a href="#函数的调用顺序" class="headerlink" title="函数的调用顺序"></a>函数的调用顺序</h3><ul>
<li>函数的定义不会执行其中代码</li>
<li>函数调用的时候先去给函数传参，当函数体中代码执行完返回到调用的地方，继续执行</li>
</ul>
<p>形参、实参略</p>
<h3 id="局部变量、全局变量"><a href="#局部变量、全局变量" class="headerlink" title="局部变量、全局变量"></a>局部变量、全局变量</h3><ul>
<li>局部变量定义：函数内定义的变量叫 局部变量，只能在函数内使用，不能在函数外使用</li>
<li>全局变量定义：在函数外定义的变量 叫 全局变量，可以在不同函数内使用，共享数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局变量</span></span><br><span class="line">score = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 局部变量</span></span><br><span class="line">    score = <span class="number">99</span></span><br><span class="line">    print(<span class="string">"分数:"</span>, score) <span class="comment"># 99</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"全局变量："</span>, score) <span class="comment"># 100</span></span><br><span class="line"><span class="comment"># print(score)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">score = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 若要修改全局变量则用 global varname 先声明一下再操作</span></span><br><span class="line">    <span class="comment"># global score = 99 写法错</span></span><br><span class="line">    <span class="keyword">global</span> score</span><br><span class="line">    score = <span class="number">99</span></span><br><span class="line">    print(<span class="string">"分数:"</span>, score)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"全局变量："</span>, score)</span><br><span class="line"><span class="comment"># print(score)</span></span><br><span class="line">show()</span><br><span class="line">show1()</span><br></pre></td></tr></table></figure>
<h3 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h3><ul>
<li>定义：在函数定义的时候参数就有值，这样的参数叫做缺省参数</li>
<li>注意事项：<ul>
<li>必选参数放到前面，默认参数在后</li>
<li>默认参数必须指向不变对象</li>
<li>默认参数只在定义时候计算一次</li>
<li>默认参数一直指向同一个对象</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(num1, num2 = <span class="number">2</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span>  num1 + num2</span><br><span class="line">print(calc(<span class="number">2</span>)) <span class="comment"># 2+2=4</span></span><br><span class="line">print(calc(<span class="number">2</span>,<span class="number">10</span>)) <span class="comment"># 2+10=12</span></span><br></pre></td></tr></table></figure>
<h3 id="调用函数传参方式"><a href="#调用函数传参方式" class="headerlink" title="调用函数传参方式"></a>调用函数传参方式</h3><ul>
<li>位置参数方式传参,必须按照 函数参数顺序 传参</li>
<li>关键字参数方式传参,可以不按照 顺序</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(name, age)</span>:</span></span><br><span class="line">    print(name, age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># positional argument</span></span><br><span class="line"><span class="comment"># 使用位置参数方式传参,必须按照 函数参数顺序 传参</span></span><br><span class="line">show(<span class="string">'zhangsan'</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># keyword argument</span></span><br><span class="line"><span class="comment"># 使用关键字参数方式传参,可以不按照 顺序</span></span><br><span class="line">show(age=<span class="number">20</span>, name=<span class="string">'lisi'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前面使用位置参数,后边可以使用关键字</span></span><br><span class="line"><span class="comment"># 前面使用关键字传参，后边必须关键字！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># show(name='111',18) 报错！</span></span><br></pre></td></tr></table></figure>
<h3 id="函数的不定长参数"><a href="#函数的不定长参数" class="headerlink" title="函数的不定长参数(*)"></a>函数的不定长参数(*)</h3><ul>
<li>定义：调用函数的时候 不确定传入多少个参数，可能是0个或多个函数</li>
</ul>
<h4 id="不定长位置参数"><a href="#不定长位置参数" class="headerlink" title="不定长位置参数"></a>不定长位置参数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="comment"># args 把传入的位置参数封装到一个元组</span></span><br><span class="line">    print(args,type(args))</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> args:</span><br><span class="line">        result += v</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">sum() <span class="comment"># () &lt;class 'tuple'&gt;</span></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment"># (1, 4, 5) &lt;class 'tuple'&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sum(args=(1,2,3))</span></span><br><span class="line"><span class="comment"># sum(a=1,b=2)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>习惯上使用*args</li>
<li>args ==&gt; 传入的位置参数封装的一个元组</li>
<li>调用函数的时候只能 使用<strong>位置传参方式</strong></li>
<li><p>形参当实参</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_msg</span><span class="params">(*args)</span>:</span></span><br><span class="line">        print(args)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(*args)</span>:</span></span><br><span class="line">        <span class="comment"># 对元组进行拆包</span></span><br><span class="line">        show_msg(*args)</span><br><span class="line">    show(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="不定长关键字参数"><a href="#不定长关键字参数" class="headerlink" title="不定长关键字参数"></a>不定长关键字参数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2. 不定长关键字参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_msg</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    print(kwargs, type(kwargs))</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.items():</span><br><span class="line">        print(k, v)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不能使用位置参数给不定长关键字函数传参</span></span><br><span class="line"><span class="comment"># show_msg(1,2)</span></span><br><span class="line">show_msg(a=<span class="number">1</span>, b=<span class="number">2</span>) <span class="comment"># &#123;'a': 1, 'b': 2&#125; &lt;class 'dict'&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>习惯上用<code>**kwargs</code></p>
</li>
<li><p>kwargs ==&gt; 传入的关键字参数 封装的 一个字典</p>
</li>
<li><p>形参当实参</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_msg</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    print(kwargs)</span><br><span class="line">    <span class="comment"># for k, v in kwargs.items():</span></span><br><span class="line">    <span class="comment">#     print(k, v)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    <span class="comment"># show_msg(a = kwargs) # &#123;'a': &#123;'a': 1, 'b': 2&#125;&#125;</span></span><br><span class="line">    <span class="comment"># show_msg(a=1, b=2)</span></span><br><span class="line">    <span class="comment"># print(**kwargs) 报错</span></span><br><span class="line">    <span class="comment"># 对字典进行拆包</span></span><br><span class="line">    show_msg(**kwargs)</span><br><span class="line">show(a=<span class="number">1</span>, b=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>禁止位置参数传参——*后边的必须用关键字参数，前边的无限制</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(*, name, age)</span>:</span></span><br><span class="line">    print(name, age)</span><br><span class="line"><span class="comment"># show("xhh", 22)</span></span><br><span class="line"><span class="comment"># TypeError: show() takes 0 positional arguments but 2 were given</span></span><br><span class="line">show(name=<span class="string">'xhh'</span>, age=<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(sex, *, name, age)</span>:</span></span><br><span class="line">    print(name, age)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="函数参数的高级使用"><a href="#函数参数的高级使用" class="headerlink" title="函数参数的高级使用"></a>函数参数的高级使用</h4><p>以下代码为正确的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># name,age 为必选参数</span></span><br><span class="line"><span class="comment"># args为不定长位置参数</span></span><br><span class="line"><span class="comment"># kwargs 为不定长关键字参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(name, age, *args, **kwargs)</span>:</span></span><br><span class="line">    print(name, age, args, kwargs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不能使用下面的方式调用，因为前边使用关键字后面不能使用位置参数</span></span><br><span class="line"><span class="comment"># show(name='李四', age=18, 10, 20, c=1, b=2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 位置方式 给 必选参数 传参</span></span><br><span class="line">show(<span class="string">'李四'</span>, <span class="number">18</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, c=<span class="number">1</span>, b=<span class="number">2</span>, d=<span class="string">'random'</span>)</span><br><span class="line"><span class="comment"># 李四 18 (10, 20, 30) &#123;'c': 1, 'b': 2, 'd': 'random'&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(*args, name, age, **kwargs)</span>:</span></span><br><span class="line">    print(name, age, args, kwargs)</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, name=<span class="string">'xiaohuihui'</span>, age=<span class="number">18</span>, aa=<span class="number">1</span>, bb=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># xiaohuihui 18 (1, 2, 3, 4) &#123;'aa': 1, 'bb': 3&#125;</span></span><br></pre></td></tr></table></figure>
<p>以下代码会有语法错误：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># **kwargs必须放到所有参数的最后边</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(**kwargs, name, age, *args)</span>:</span></span><br><span class="line">    print(name, age, args, kwargs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(name, age,**kwargs, *args)</span>:</span></span><br><span class="line">    print(name, age, args, kwargs)</span><br></pre></td></tr></table></figure>
<p>跟缺省参数的结合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置了缺省参数，但是没效果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(name, age = <span class="number">18</span>, *args, **kwargs)</span>:</span></span><br><span class="line">    print(name, age, args, kwargs)</span><br><span class="line">show(<span class="string">'zhangsan'</span>, <span class="string">'haha'</span>, <span class="string">'xixi'</span>, a=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># zhangsan haha ('xixi',) &#123;'a': 10&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要使用默认参数，需要放到*args后边</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(name, *args, age = <span class="number">18</span>, **kwargs)</span>:</span></span><br><span class="line">    print(name, age, args, kwargs)</span><br><span class="line">show(<span class="string">'zhangsan'</span>, <span class="string">'haha'</span>, <span class="string">'xixi'</span>, a=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># zhangsan 18 ('haha', 'xixi') &#123;'a': 10&#125;</span></span><br><span class="line">show(<span class="string">'zhangsan'</span>, <span class="string">'haha'</span>, <span class="string">'xixi'</span>, age= <span class="number">10</span>, a=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># zhangsan 10 ('haha', 'xixi') &#123;'a': 10&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="函数的注意事项"><a href="#函数的注意事项" class="headerlink" title="函数的注意事项"></a>函数的注意事项</h3><ul>
<li>函数名不能相同，无重载，如果定义了第二个函数名和第一个函数名相同，那么第一个函数不能使用</li>
<li>变量名 和 函数名 不能相同</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"不带参数的show"</span>)</span><br><span class="line">show()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(msg)</span>:</span></span><br><span class="line">    print(msg)</span><br><span class="line">show(<span class="string">"带参数的show"</span>)</span><br><span class="line">show = <span class="number">10</span></span><br><span class="line"><span class="comment"># show()  TypeError: 'int' object is not callable</span></span><br></pre></td></tr></table></figure>
<h3 id="函数嵌套"><a href="#函数嵌套" class="headerlink" title="函数嵌套"></a>函数嵌套</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在函数里边再定义一个函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"在我show函数内部定义"</span>)</span><br><span class="line">    <span class="comment"># test() 没有这个调用则无法执行</span></span><br><span class="line">show()</span><br><span class="line"><span class="comment"># test()</span></span><br></pre></td></tr></table></figure>
<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><ul>
<li>定义：函数里边再调用函数本身</li>
<li>特点：传递、回归</li>
<li>注意：<ul>
<li>不能无限次递归调用</li>
<li>必须设置结束递归的条件及返回值</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gc</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="comment"># 当计算1! 时不需要往下传递，需要返回结果</span></span><br><span class="line">    <span class="comment"># 必须要设置结束递归的条件</span></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> num * gc(num - <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 获取默认的递归次数</span></span><br><span class="line">print(sys.getrecursionlimit()) <span class="comment"># 1000</span></span><br><span class="line">print(gc(<span class="number">6</span>)) <span class="comment"># 720</span></span><br><span class="line"><span class="comment"># print(gc(1000)) 因超出次数无法调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置递归次数</span></span><br><span class="line">sys.setrecursionlimit(<span class="number">1100</span>)</span><br><span class="line">print(gc(<span class="number">1000</span>))</span><br></pre></td></tr></table></figure>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数*"></a>匿名函数*</h3><ul>
<li>定义：顾名思义就是函数没有名字，使用lambda关键字定义的函数就是匿名函数</li>
<li>注意事项：<ul>
<li>只适合做一下简单的操作，返回值不需要加return</li>
<li>一般使用变量保持匿名函数</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只适合做一下简单的操作，返回值不需要加return</span></span><br><span class="line">result = (<span class="keyword">lambda</span> x, y: x + y)(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">print(result) <span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 使用变量保持匿名函数</span></span><br><span class="line">mult = <span class="keyword">lambda</span> x, y:x * y</span><br><span class="line">print(mult(<span class="number">2</span>,<span class="number">5</span>)) <span class="comment"># 10</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">print(type(fun)) <span class="comment"># &lt;class 'function'&gt;</span></span><br><span class="line">print(type(mult)) <span class="comment"># &lt;class 'function'&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否是奇数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">print(is_odd(<span class="number">3</span>)) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匿名函数的应用场景——简化代码</span></span><br><span class="line">new_is_odd = <span class="keyword">lambda</span> num: <span class="literal">False</span> <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="literal">True</span></span><br><span class="line">print(new_is_odd(<span class="number">4</span>)) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对字典列表排序的时候 可以 使用匿名函数</span></span><br><span class="line">my_list = [&#123;<span class="string">"name"</span>: <span class="string">'zs'</span>, <span class="string">"age"</span>: <span class="number">20</span>&#125;, &#123;<span class="string">"name"</span>: <span class="string">'zs'</span>, <span class="string">"age"</span>: <span class="number">18</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># item: 表示列中的每一项字典数据</span></span><br><span class="line"><span class="comment"># item:["age"] 根据字典中age对应的value值进行排序</span></span><br><span class="line">my_list.sort(key=<span class="keyword">lambda</span> item: item[<span class="string">"age"</span>], reverse = <span class="literal">False</span>)</span><br><span class="line">print(my_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匿名函数也是函数,上述lambda匿名函数可转化为下面的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_value</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> item[<span class="string">"age"</span>]</span><br></pre></td></tr></table></figure>
<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><ul>
<li>内置函数就是 python 自己定义的函数，可以直接使用，无须导入包<ul>
<li>len,max,min,sorted,open,lower</li>
<li><code>id()</code> 获取10进制内存地址</li>
<li><code>hex(id()) </code>获取十六进制内存地址</li>
<li><code>dir(object)</code> 返回对象的属性/方法列表</li>
<li><code>isinstance(obj, class)</code>  判断obj是不是class类型</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># len() 统计容器类型 元素个数</span></span><br><span class="line">print(len(<span class="string">"abc"</span>))</span><br><span class="line">print(len([<span class="string">"aa"</span>, <span class="string">"bc"</span>]))</span><br><span class="line">print(len((<span class="number">1</span>, <span class="number">2</span>)))</span><br><span class="line"><span class="comment"># max() 统计容器类型数据中的最大值</span></span><br><span class="line">print(max(<span class="string">"538"</span>))</span><br><span class="line">print(max([<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>]))</span><br><span class="line"><span class="comment"># sorted 排序</span></span><br><span class="line">new_list = sorted([<span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line">print(new_list) <span class="comment"># [6, 7, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># del() 可以删除变量</span></span><br><span class="line"><span class="keyword">del</span>(new_list)</span><br><span class="line"><span class="comment"># print(new_list)</span></span><br></pre></td></tr></table></figure>
<h3 id="函数的文档说明"><a href="#函数的文档说明" class="headerlink" title="函数的文档说明"></a>函数的文档说明</h3><p>三方公司 查看自己公司 接口方法或者函数的时候需要使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(num1, num2)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    计算数字之和</span></span><br><span class="line"><span class="string">    :param num1:第一个数字</span></span><br><span class="line"><span class="string">    :param num2:第二个数字</span></span><br><span class="line"><span class="string">    :return:返回 和</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line"></span><br><span class="line">value = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">help(add)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">add(num1, num2)</span></span><br><span class="line"><span class="string">    计算数字之和</span></span><br><span class="line"><span class="string">    :param num1:第一个数字</span></span><br><span class="line"><span class="string">    :param num2:第二个数字</span></span><br><span class="line"><span class="string">    :return:返回 和</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">help(len)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Help on built-in function len in module builtins:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">len(obj, /)</span></span><br><span class="line"><span class="string">    Return the number of items in a container.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h3 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h3><ul>
<li>通俗理解：指明函数的参数偏爱某个值，这样的函数叫做偏函数</li>
<li>引子</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需求：num3不想传递</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(num1, num2, num3 = <span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> num1 + num2 + num3</span><br><span class="line"></span><br><span class="line">print(show(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但有些时候还需要用到其他值，但不想传</span></span><br><span class="line"><span class="comment"># 定义一个偏函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show2</span><span class="params">(num1, num2, num3 = <span class="number">2</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> show(num1, num2, num3)</span><br><span class="line">print(show2(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment"># 5</span></span><br><span class="line"><span class="comment"># 注意定义有些复杂，相当于重新定义了一次函数，但也算偏函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>functools包的使用</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(num1, num2, num3 = <span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> num1 + num2 + num3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指明函数的参数设置为某个值</span></span><br><span class="line">show2 = functools.partial(show, num3 = <span class="number">2</span>) <span class="comment"># 返回的函数就是偏函数</span></span><br><span class="line">print(show2(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指明内置函数的参数偏爱某个值，生成一个偏函数</span></span><br><span class="line"><span class="comment"># int()默认按照 10进制 进行转</span></span><br><span class="line">print(int(<span class="string">"123"</span>)) <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line">new_func = functools.partial(int, base = <span class="number">2</span>)</span><br><span class="line">print(new_func(<span class="string">'11'</span>)) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<h3 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h3><ul>
<li>返回函数：在函数里边返回一个函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数的嵌套</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'hahaha'</span>)</span><br><span class="line">    <span class="comment"># 返回了一个函数</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="comment"># 获得返回的函数</span></span><br><span class="line">new_func = show()</span><br><span class="line"><span class="comment"># 执行返回的函数</span></span><br><span class="line">new_func() <span class="comment"># hahaha</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此函数可作为18.17高阶函数中 函数返回一个函数 的例子</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(opt)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> opt == <span class="string">'+'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> num1,num2 : num1+num2</span><br><span class="line">    <span class="keyword">if</span> opt == <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> num1,num2 : num1-num2</span><br><span class="line">new_func = calc(<span class="string">'-'</span>)</span><br><span class="line">print(new_func(<span class="number">1</span>,<span class="number">2</span>)) <span class="comment"># -1</span></span><br></pre></td></tr></table></figure>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><ul>
<li>高阶函数：一个函数的参数 接受 另外一个函数 或者 返回一个函数</li>
<li>针对的是 把函数 作为参数或者返回值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义一个普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(num1, num2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高阶函数——将函数作为参数接收</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_num</span><span class="params">(num1, num2, func)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> func(num1, num2)</span><br><span class="line"></span><br><span class="line">print(calc_num(<span class="number">4</span>,<span class="number">5</span>,add)) <span class="comment"># 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 高阶函数——返回一个函数例子见 返回函数一节</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 高阶函数 - 综合两种情况</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(func)</span>:</span></span><br><span class="line">    func()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> :print(<span class="string">"lambda called"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_msg</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"show_msg called"</span>)</span><br><span class="line"></span><br><span class="line">new_func = test(show_msg) <span class="comment"># show_msg called</span></span><br><span class="line">new_func() <span class="comment"># lambda called</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一步到位</span></span><br><span class="line">test(show_msg)()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">show_msg called</span></span><br><span class="line"><span class="string">lambda called</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li>闭包：在函数嵌套的情况下，内部函数使用了外部函数的参数或者变量，并把这个内部函数返回，返回的函数称为闭包</li>
<li>条件：<ul>
<li>函数嵌套情况下</li>
<li>内部函数使用外部函数的参数/变量</li>
<li>返回这个内部函数</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(msg)</span>:</span></span><br><span class="line">    num = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(num, msg)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">new_func = show(<span class="string">"哈哈"</span>)</span><br><span class="line">print(new_func) <span class="comment"># &lt;function show.&lt;locals&gt;.inner at 0x00000116C077BBF8&gt;</span></span><br><span class="line">new_func() <span class="comment"># 10 哈哈</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>应用场景：可以根据参数生成不同的返回函数(闭包)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(msg, count)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> msg, count: msg*count</span><br><span class="line">new_func1 = hello(<span class="string">"A"</span>, <span class="number">2</span>)</span><br><span class="line">print(new_func1()) <span class="comment"># AA</span></span><br><span class="line">print(new_func1()) <span class="comment"># AA</span></span><br><span class="line">new_func2 = hello(<span class="string">"B"</span>, <span class="number">2</span>)</span><br><span class="line">print(new_func2()) <span class="comment"># BB</span></span><br><span class="line">print(new_func2()) <span class="comment"># BB</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器**"></a>装饰器**</h3><h4 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h4><ul>
<li>装饰器： 本质上就是一个函数</li>
<li>作用：给原函数的功能上进行拓展</li>
<li>好处：不改变原函数的定义及调用的操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"AAAA"</span>)</span><br><span class="line"></span><br><span class="line">show() <span class="comment"># AAAA</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器--&gt; 通过闭包完成</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(new_func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'-'</span> * <span class="number">10</span>)</span><br><span class="line">        new_func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="comment"># 原有的show环境并没有被清除 --&gt; 不改变原函数的定义</span></span><br><span class="line">show = decorator(show)</span><br><span class="line">show()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">----------</span></span><br><span class="line"><span class="string">AAAA</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h4 id="使用语法糖"><a href="#使用语法糖" class="headerlink" title="使用语法糖@"></a>使用语法糖@</h4><ul>
<li>在使用@的时候装饰器的代码就会执行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 装饰器--&gt; 通过闭包完成</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(new_func)</span>:</span></span><br><span class="line">    print(<span class="string">"decorator called"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'-'</span> * <span class="number">10</span>)</span><br><span class="line">        new_func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="meta">@decorator # show = decorator(show)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"AAAA"</span>)</span><br><span class="line">show()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">----------</span></span><br><span class="line"><span class="string">AAAA</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">decorator: &lt;function decorator at 0x000002ABE7DDAE18&gt;</span></span><br><span class="line"><span class="string">new_func: &lt;function show at 0x000002ABE7DDAF28&gt;</span></span><br><span class="line"><span class="string">inner: &lt;function decorator.&lt;locals&gt;.inner at 0x000002ABE7F61048&gt;</span></span><br><span class="line"><span class="string">show: &lt;function decorator.&lt;locals&gt;.inner at 0x000002ABE7F61048&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">show, 00-hello_py.py:10</span></span><br><span class="line"><span class="string">inner, 00-hello_py.py:6</span></span><br><span class="line"><span class="string">&lt;module&gt;, 00-hello_py.py:11</span></span><br><span class="line"><span class="string">execfile, _pydev_execfile.py:18</span></span><br><span class="line"><span class="string">run, pydevd.py:1135</span></span><br><span class="line"><span class="string">main, pydevd.py:1735</span></span><br><span class="line"><span class="string">&lt;module&gt;, pydevd.py:1741</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h4 id="设计装饰器"><a href="#设计装饰器" class="headerlink" title="设计装饰器"></a>设计装饰器</h4><p>根据装饰器内的函数特点可分为以下几类：</p>
<ul>
<li><p>不带参数，无返回值(见18.19.2)</p>
</li>
<li><p>带参数，无返回值 —— 在inner加入参数并调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 装饰器--&gt; 通过闭包完成</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(num1, num2)</span>:</span></span><br><span class="line">        print(<span class="string">"计算结果如下："</span>)</span><br><span class="line">        func(num1, num2)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="meta">@decorator # show = decorator(show)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(num1, num2)</span>:</span></span><br><span class="line">    print(num1 + num2)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">计算结果如下：</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>​    带参数，有返回值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 装饰器--&gt; 通过闭包完成</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"decorator called"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(num1, num2)</span>:</span></span><br><span class="line">        print(<span class="string">"计算结果如下："</span>)</span><br><span class="line">        <span class="keyword">return</span> func(num1, num2)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="meta">@decorator # show = decorator(show)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(num1, num2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">msg</span><span class="params">(num1, num2)</span>:</span></span><br><span class="line">    print(num1, num2)</span><br><span class="line"></span><br><span class="line">print(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">计算结果如下：</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">print(msg(<span class="string">'hello'</span>,<span class="string">'111'</span>))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">计算结果如下：</span></span><br><span class="line"><span class="string">hello 111</span></span><br><span class="line"><span class="string">None</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p>亦可装饰无返回值的函数，只不过返回了None</p>
<blockquote>
<p>亦可装饰内置函数，但只能采用手动赋值的形式，不能用语法糖，另外参数和返回值需要处理妥当</p>
</blockquote>
</li>
</ul>
<h4 id="通用装饰器"><a href="#通用装饰器" class="headerlink" title="通用装饰器"></a>通用装饰器</h4><p>上述装饰器存在如下问题：</p>
<ul>
<li>被装饰的函数 和 装饰器里边的函数 参数需要一致</li>
</ul>
<p>可用不定长参数解决这一问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"decorator called"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 装饰代码</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure>
<h4 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h4><p>先观察下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator1</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"A"</span>* <span class="number">10</span>)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator2</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"B"</span>* <span class="number">10</span>)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator3</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"C"</span>* <span class="number">10</span>)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">1111</span>)</span><br><span class="line"></span><br><span class="line">show()</span><br></pre></td></tr></table></figure>
<p>当出现需要根据不同参数生成不同装饰器时，这种做法显然不妥</p>
<p>可定义带参数的装饰器，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_decorator</span><span class="params">(char)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">            print(char * <span class="number">10</span>)</span><br><span class="line">            func()</span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@get_decorator('S')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">1111</span>)</span><br><span class="line"></span><br><span class="line">show()</span><br></pre></td></tr></table></figure>
<h4 id="函数使用多个装饰器"><a href="#函数使用多个装饰器" class="headerlink" title="函数使用多个装饰器"></a>函数使用多个装饰器</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator1</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'-'</span> * <span class="number">30</span>)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator2</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'*'</span> * <span class="number">30</span>)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="meta">@decorator1 # show = decorator1(decorator2.inner) =&gt; decorator1.inner</span></span><br><span class="line"><span class="meta">@decorator2 # show = decorator2(show) -&gt; decorator2.inner</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'AAAA'</span>)</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">------------------------------</span></span><br><span class="line"><span class="string">******************************</span></span><br><span class="line"><span class="string">AAAA</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片*"></a>切片*</h2><ul>
<li>定义：根据下标的范围获取一部分数据，比如：列表、字符串可以使用切片</li>
<li><p>使用格式：element[start, end, step]</p>
<ul>
<li>start为起始下标，默认为0</li>
<li>end为结束下标，不包含</li>
<li>step为步长，默认是1</li>
</ul>
</li>
<li><p>使用技巧</p>
<ul>
<li>前n个[0:3] 简化为 [:3]</li>
<li>后n个[-n:]</li>
<li>全部[:]</li>
<li>倒置[::-1]</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str = <span class="string">"hello"</span></span><br><span class="line">print(my_str[<span class="number">1</span>:<span class="number">4</span>]) <span class="comment"># ell</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取前3位</span></span><br><span class="line">print(my_str[<span class="number">0</span>:<span class="number">3</span>]) <span class="comment"># hel</span></span><br><span class="line">print(my_str[:<span class="number">3</span>]) <span class="comment"># hel</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取后3位</span></span><br><span class="line">print(my_str[<span class="number">2</span>:<span class="number">5</span>]) <span class="comment"># llo</span></span><br><span class="line"><span class="comment"># 冒号后跟-1 —— 最后1个数据取不到</span></span><br><span class="line">print(my_str[<span class="number">-3</span>:<span class="number">-1</span>]) <span class="comment"># ll</span></span><br><span class="line">print(my_str[<span class="number">-3</span>:<span class="number">0</span>]) <span class="comment"># 空串,0表示第1个数据，在-3的前边</span></span><br><span class="line"><span class="comment"># 冒号后面不知道——表示可以去到最后1个数据</span></span><br><span class="line">print(my_str[<span class="number">-3</span>:]) <span class="comment"># llo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速获取整个字符串</span></span><br><span class="line"><span class="comment"># result = my_str[0:5]</span></span><br><span class="line">result = my_str[:]</span><br><span class="line">print(result) <span class="comment"># hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 步长是负数 表示 从后往前取值</span></span><br><span class="line">print(my_str[<span class="number">-2</span>:<span class="number">-5</span>:<span class="number">-1</span>]) <span class="comment"># lle</span></span><br><span class="line">print(my_str[<span class="number">3</span>:<span class="number">0</span>:<span class="number">-1</span>]) <span class="comment"># lle</span></span><br><span class="line">print(my_str[::<span class="number">-1</span>]) <span class="comment"># olleh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 间隔的取</span></span><br><span class="line">print(my_str[::<span class="number">2</span>]) <span class="comment"># hlo</span></span><br></pre></td></tr></table></figure>
<h2 id="列表生成式-列表推导式"><a href="#列表生成式-列表推导式" class="headerlink" title="列表生成式(列表推导式)"></a>列表生成式(列表推导式)</h2><ul>
<li>通俗理解：使用for循环快速创建一个列表，最终获取一个列表</li>
<li>目的：快速创建一个列表</li>
<li>语法格式：<code>[表达式 for val in xxx]</code> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">    my_list.append(i)</span><br><span class="line">print(my_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表推导式目的：快速创建一个列表</span></span><br><span class="line">print([val <span class="keyword">for</span> val <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>)])</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5]</span></span><br><span class="line">print([val*<span class="number">2</span> <span class="keyword">for</span> val <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>)])</span><br><span class="line"><span class="comment"># [2, 4, 6, 8, 10]</span></span><br><span class="line">print([len(val) <span class="keyword">for</span> val <span class="keyword">in</span> [<span class="string">"aaa"</span>, <span class="string">"cd"</span>]])</span><br><span class="line"><span class="comment"># [3, 2]</span></span><br><span class="line">print([val+<span class="string">"hello"</span> <span class="keyword">for</span> val <span class="keyword">in</span> [<span class="string">"aaa"</span>, <span class="string">"cd"</span>]])</span><br><span class="line"><span class="comment"># ['aaahello', 'cdhello']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双for</span></span><br><span class="line">print([(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">3</span>) <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">4</span>, <span class="number">6</span>)])</span><br><span class="line"><span class="comment"># [(1, 4), (1, 5), (2, 4), (2, 5)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入if判断</span></span><br><span class="line">print([val <span class="keyword">for</span> val <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> val % <span class="number">2</span> == <span class="number">0</span>])</span><br><span class="line"><span class="comment"># [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li>通俗理解：程序中的数据在内存中的地址，简称内存地址</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = a</span><br><span class="line">print(<span class="string">"a保存的数据的内存地址："</span>, hex(id(a))) <span class="comment"># 0x7fffa6bae470</span></span><br><span class="line">print(<span class="string">"b保存的数据的内存地址："</span>, hex(id(b))) <span class="comment"># 0x7fffa6bae470</span></span><br><span class="line">print(a, b) <span class="comment"># 10 10</span></span><br><span class="line">a = <span class="number">20</span></span><br><span class="line">print(<span class="string">"a保存的数据的内存地址："</span>, hex(id(a))) <span class="comment"># 0x7fffa6bae5b0</span></span><br><span class="line">print(<span class="string">"b保存的数据的内存地址："</span>, hex(id(b))) <span class="comment"># 0x7fffa6bae470</span></span><br><span class="line">print(a, b) <span class="comment"># 20 10</span></span><br></pre></td></tr></table></figure>
<h2 id="可变类型和不可变类型"><a href="#可变类型和不可变类型" class="headerlink" title="可变类型和不可变类型"></a>可变类型和不可变类型</h2><ul>
<li>可变类型：可在在原有数据基础上对数据进行修改(增删改)，修改后内存地址不变<ul>
<li>举例：列表、集合、字典</li>
<li>(自注)这里不变的是变量本身的存放的地址，该地址 指向的内存空间 仍然是地址</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="comment"># 查看内存地址</span></span><br><span class="line">print(str(my_list) + <span class="string">" &lt;-- "</span> + hex(id(my_list)))</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> my_list:</span><br><span class="line">    print(<span class="string">"%d &lt;-- "</span> % val +hex(id(val)))</span><br><span class="line"></span><br><span class="line">my_list[<span class="number">0</span>] = <span class="number">2</span></span><br><span class="line">my_list.append(<span class="number">7</span>)</span><br><span class="line">print(str(my_list) + <span class="string">" &lt;-- "</span> + hex(id(my_list)))</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> my_list:</span><br><span class="line">    print(<span class="string">"%d &lt;-- "</span> % val +hex(id(val)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> my_list[<span class="number">1</span>]</span><br><span class="line">print(str(my_list) + <span class="string">" &lt;-- "</span> + hex(id(my_list)))</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> my_list:</span><br><span class="line">    print(<span class="string">"%d &lt;-- "</span> % val +hex(id(val)))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>] &lt;-- <span class="number">0x1fc05156288</span></span><br><span class="line"><span class="number">1</span> &lt;-- <span class="number">0x7fffbc0fe350</span></span><br><span class="line"><span class="number">5</span> &lt;-- <span class="number">0x7fffbc0fe3d0</span></span><br><span class="line"><span class="number">6</span> &lt;-- <span class="number">0x7fffbc0fe3f0</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>] &lt;-- <span class="number">0x1fc05156288</span></span><br><span class="line"><span class="number">2</span> &lt;-- <span class="number">0x7fffbc0fe370</span></span><br><span class="line"><span class="number">5</span> &lt;-- <span class="number">0x7fffbc0fe3d0</span></span><br><span class="line"><span class="number">6</span> &lt;-- <span class="number">0x7fffbc0fe3f0</span></span><br><span class="line"><span class="number">7</span> &lt;-- <span class="number">0x7fffbc0fe410</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>] &lt;-- <span class="number">0x1fc05156288</span></span><br><span class="line"><span class="number">2</span> &lt;-- <span class="number">0x7fffbc0fe370</span></span><br><span class="line"><span class="number">6</span> &lt;-- <span class="number">0x7fffbc0fe3f0</span></span><br><span class="line"><span class="number">7</span> &lt;-- <span class="number">0x7fffbc0fe410</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不可变类型：不能在原有数据基础上对数据进行修改，当然直接赋值一个新值，那么内存地址会发生改变（实际上改的是内存地址）<ul>
<li>字符串，数字，元组</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_str = <span class="string">"hello"</span></span><br><span class="line">print(hex(id(my_str)) + <span class="string">" --&gt; "</span> + my_str)</span><br><span class="line"><span class="comment"># my_str[0] = 'a' 不能修改数据！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新赋值后，变量的内存地址发生改变，指向新的元素的地址空间</span></span><br><span class="line">my_str = <span class="string">"world"</span></span><br><span class="line">print(hex(id(my_str)) + <span class="string">" --&gt; "</span> + my_str)</span><br><span class="line"></span><br><span class="line">my_num = <span class="number">5</span></span><br><span class="line">print(hex(id(my_num)) + <span class="string">" --&gt; "</span> + str(my_num))</span><br><span class="line"><span class="comment"># my_num[0] = 1</span></span><br><span class="line">my_num = <span class="number">6</span></span><br><span class="line">print(hex(id(my_num)) + <span class="string">" --&gt; "</span> + str(my_num))</span><br><span class="line"></span><br><span class="line">my_tuple = (<span class="number">4</span>, <span class="number">6</span>)</span><br><span class="line">print(hex(id(my_tuple)) + <span class="string">" --&gt; "</span> + str(my_tuple))</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> my_tuple:</span><br><span class="line">    print(hex(id(val)) + <span class="string">" --&gt; "</span> + str(val))</span><br><span class="line"><span class="comment"># my_tuple[0] = 5</span></span><br><span class="line">my_tuple = (<span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">print(hex(id(my_tuple)) + <span class="string">" --&gt; "</span> + str(my_tuple))</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> my_tuple:</span><br><span class="line">    print(hex(id(val)) + <span class="string">" --&gt; "</span> + str(val))</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">0x1831f259538 --&gt; hello</span><br><span class="line">0x1831f312848 --&gt; world</span><br><span class="line">0x7fffbc3ce3d0 --&gt; 5</span><br><span class="line">0x7fffbc3ce3f0 --&gt; 6</span><br><span class="line">0x1831f311988 --&gt; (4, 6)</span><br><span class="line">0x7fffbc3ce3b0 --&gt; 4</span><br><span class="line">0x7fffbc3ce3f0 --&gt; 6</span><br><span class="line">0x1831f3e6708 --&gt; (5, 6)</span><br><span class="line">0x7fffbc3ce3d0 --&gt; 5</span><br><span class="line">0x7fffbc3ce3f0 --&gt; 6</span><br></pre></td></tr></table></figure>
<blockquote>
<p>个人总结：基本类型对象int, float, bool 等变量直接存放 对象的地址，地址处存放对象本身</p>
<p>例如数字5，本身的地址并不发生变化</p>
<p>集合类型变量存放的地址处，是若干对象的地址？（不严谨）并非对象本身</p>
<p>元组、字符串不能修改，变化后变量地址变化，地址中的 对象地址部分发生变化</p>
<p>列表、字典、集合 变化后 变量地址不变，变化的是地址中的 对象地址</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>地址内容</th>
<th>数据发生变化</th>
<th>实质</th>
</tr>
</thead>
<tbody>
<tr>
<td>不可变</td>
<td>重新赋值      变量地址发生变化</td>
<td>变量指向 新对象(集合) 的存放的地址</td>
</tr>
<tr>
<td>可变</td>
<td>增删改后      变量地址不变</td>
<td>集合地址不变，但集合中指向对象的地址发生变化</td>
</tr>
</tbody>
</table>
</div>
<h2 id="global的使用-拓展"><a href="#global的使用-拓展" class="headerlink" title="global的使用 - 拓展"></a>global的使用 - 拓展</h2><h3 id="global与不可变类型"><a href="#global与不可变类型" class="headerlink" title="global与不可变类型"></a>global与不可变类型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义不可变类型全局变量</span></span><br><span class="line">g_num = <span class="number">10</span></span><br><span class="line">print(<span class="string">"函数外g_num:"</span>, hex(id(g_num)), <span class="string">"--&gt;"</span>, g_num)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 声明要修改全局变量, 表示要修改全局变量的内存地址</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    g_num = <span class="number">1</span></span><br><span class="line">    print(<span class="string">"函数内g_num:"</span>, hex(id(g_num)), <span class="string">"--&gt;"</span>, g_num)</span><br><span class="line"></span><br><span class="line">modify()</span><br><span class="line">print(g_num)</span><br></pre></td></tr></table></figure>
<h3 id="global与可变类型"><a href="#global与可变类型" class="headerlink" title="global与可变类型"></a>global与可变类型</h3><ul>
<li>不加global</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义可变类型的全局变量</span></span><br><span class="line">g_list = [<span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">print(<span class="string">"函数外g_list:"</span>, hex(id(g_list)), <span class="string">"--&gt;"</span>, g_list)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 在原有数据基础上 添加了一个数据</span></span><br><span class="line">    <span class="comment"># 如果只是修改数据，这里不需要加上global,加上也不会有问题</span></span><br><span class="line">    <span class="comment"># global g_list 加上也不会受到影响</span></span><br><span class="line">    g_list.append(<span class="number">4</span>)</span><br><span class="line">    print(<span class="string">"函数内g_list:"</span>, hex(id(g_list)), <span class="string">"--&gt;"</span>, g_list)</span><br><span class="line">modify()</span><br><span class="line">print(g_list)</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">函数外g_list: 0x22b58286288 --&gt; [3, 5]</span><br><span class="line">函数内g_list: 0x22b58286288 --&gt; [3, 5, 4]</span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>分析：内存地址不发生变化的情况下，不用加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义可变类型的全局变量</span></span><br><span class="line">g_list = [<span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">print(<span class="string">"函数外g_list:"</span>, hex(id(g_list)), <span class="string">"--&gt;"</span>, g_list)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify</span><span class="params">()</span>:</span></span><br><span class="line">    g_list = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    print(<span class="string">"函数内g_list:"</span>, hex(id(g_list)), <span class="string">"--&gt;"</span>, g_list)</span><br><span class="line">modify()</span><br><span class="line">print(g_list)</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">函数外g_list: 0x1f5daf96288 --&gt; [3, 5]</span><br><span class="line">函数内g_list: 0x1f5db1960c8 --&gt; [1, 2]</span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>加global</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义可变类型的全局变量</span></span><br><span class="line">g_list = [<span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">print(<span class="string">"函数外g_list:"</span>, hex(id(g_list)), <span class="string">"--&gt;"</span>, g_list)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_list</span><br><span class="line">    g_list = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    print(<span class="string">"函数内g_list:"</span>, hex(id(g_list)), <span class="string">"--&gt;"</span>, g_list)</span><br><span class="line">modify()</span><br><span class="line">print(g_list)</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">函数外g_list: 0x272c88b6288 --&gt; [3, 5]</span><br><span class="line">函数内g_list: 0x272ca5a1588 --&gt; [1, 2]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要在函数内 修改 全局变量 内存地址，必须加上global关键字</p>
<p>对于可变类型，只修改数据，可以不加global</p>
</blockquote>
<h2 id="公共运算符的操作"><a href="#公共运算符的操作" class="headerlink" title="公共运算符的操作"></a>公共运算符的操作</h2><h3 id="运算符-拼接"><a href="#运算符-拼接" class="headerlink" title="+运算符 拼接"></a>+运算符 拼接</h3><ul>
<li>可以完成列表、元组、字符串的拼接</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"hello"</span>+<span class="string">"world"</span>) <span class="comment"># helloworld</span></span><br><span class="line">print([<span class="number">1</span>, <span class="number">3</span>]+[<span class="number">4</span>, <span class="number">5</span>]) <span class="comment"># [1, 3, 4, 5]</span></span><br><span class="line">print((<span class="number">1</span>, <span class="number">3</span>)+(<span class="number">4</span>, <span class="number">5</span>)) <span class="comment"># (1, 3, 4, 5)</span></span><br></pre></td></tr></table></figure>
<h3 id="运算符-复制"><a href="#运算符-复制" class="headerlink" title="*运算符 复制"></a>*运算符 复制</h3><ul>
<li>可以完成列表、元组、字符串的复制</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'-'</span>*<span class="number">15</span>) <span class="comment"># ---------------</span></span><br><span class="line">print(<span class="string">'ab'</span>*<span class="number">5</span>) <span class="comment"># ababababab</span></span><br><span class="line">print([<span class="number">1</span>, <span class="number">2</span>] * <span class="number">3</span>) <span class="comment"># [1, 2, 1, 2, 1, 2]</span></span><br><span class="line">print((<span class="number">4</span>, <span class="number">5</span>) * <span class="number">3</span>) <span class="comment"># (4, 5, 4, 5, 4, 5)</span></span><br></pre></td></tr></table></figure>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="文件的介绍"><a href="#文件的介绍" class="headerlink" title="文件的介绍"></a>文件的介绍</h3><p>可以做到数据的永久存储，文件以硬盘为载体</p>
<h3 id="文件读写操作"><a href="#文件读写操作" class="headerlink" title="文件读写操作"></a>文件读写操作</h3><ul>
<li><code>open()</code> 打开文件<ul>
<li>文件访问模式<ul>
<li>r 只读，文件不存在会抛出异常</li>
<li>w 只写<ul>
<li>文件不存在则会创建文件并打开</li>
<li>如果文件存在，先把原有数据清空</li>
</ul>
</li>
<li>a 追加写入</li>
<li>rb 二进制方式读取文件数据</li>
<li>wb 二进制方式写入文件数据</li>
<li>ab 二进制方式追加写入文件数据</li>
<li>r+ , w+ , a+ 支持读写，但要看前面的主模式<ul>
<li>r+  写入数据时候不会先清空数据，会从开头开始覆盖</li>
</ul>
</li>
<li>rb+ , wb+ , ab+ 支持二进制方式读写模式</li>
</ul>
</li>
<li>设定编码 encoding=”utf-8”<ul>
<li>Windows下默认编码为GBK / cp936</li>
<li>Linux、MacOS下默认编码为UTF-8</li>
<li><strong>二进制模式不需要指定编码模式</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>python2中不支持中文，需要指定编码格式</p>
<p>python3支持中文，使用utf-8编码</p>
</blockquote>
<ul>
<li><p><code>write()</code> 支持写入的方式打开文件后，写入文件</p>
<ul>
<li>多次写入数据不会覆盖前面的数据</li>
<li>编码格式采用指定的编码</li>
</ul>
</li>
<li><p><code>read()</code> 读取文件</p>
<ul>
<li>如果打开文件时候指定的编码 与 文件编码 不一致会抛出异常 UnicodeDecodeError: ‘gbk’ codec can’t decode byte 0xad in position 2: illegal multibyte sequence(Python3.7)</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开文件使用open函数</span></span><br><span class="line"><span class="comment"># ------- r模式 -------</span></span><br><span class="line">file = open(<span class="string">"1.txt"</span>, <span class="string">"r"</span>, encoding=<span class="string">"utf-8"</span>) <span class="comment"># 默认r模式</span></span><br><span class="line">content = file.read()</span><br><span class="line">print(content) <span class="comment"># 中文world</span></span><br><span class="line">file.close()</span><br><span class="line"><span class="comment"># ------- w模式 -------</span></span><br><span class="line"><span class="comment"># file = open("1.txt", "w", encoding="utf-8")</span></span><br><span class="line"><span class="comment"># file.write("中文")</span></span><br><span class="line"><span class="comment"># file.write("world")</span></span><br><span class="line"><span class="comment"># file.close()</span></span><br><span class="line"><span class="comment"># a模式略</span></span><br><span class="line"></span><br><span class="line">file = open(<span class="string">"1.txt"</span>, <span class="string">'rb'</span>,)</span><br><span class="line">content = file.read()</span><br><span class="line">print(content) <span class="comment"># b'\xe4\xb8\xad\xe6\x96\x87world'</span></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>
<h3 id="文件的不同读取操作"><a href="#文件的不同读取操作" class="headerlink" title="文件的不同读取操作"></a>文件的不同读取操作</h3><ul>
<li><p><code>read()</code> 从文件指针处开始 读取，读取后文件指针改变</p>
</li>
<li><p>read(1) 表示从文件指针处开始读取1个长度数据，可能是一个汉字，也可能是一个字母</p>
<ul>
<li>rb模式的话是指定读取的字节数，读取后需要解码decode</li>
</ul>
</li>
<li><p><code>tell()</code> 查看文件指针的位置</p>
</li>
<li><code>seek()</code> 设置文件指针的位置</li>
<li><code>readline()</code>  读取一行数据<ul>
<li>当遇到’\n’(也会读到)表示读取数据结束</li>
</ul>
</li>
<li><p><code>readlines()</code></p>
<ul>
<li>把每行的数据放到一个列表中</li>
</ul>
<h3 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h3></li>
<li><p>小文件拷贝</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.打开原文件读取数据</span></span><br><span class="line"><span class="comment"># rb模式：比较通用的模式，可以兼容不同类型的文件</span></span><br><span class="line">src_file = open(<span class="string">"3.txt"</span>, <span class="string">"rb"</span>)</span><br><span class="line"><span class="comment"># 读取文件中的全部数据</span></span><br><span class="line">file_data = src_file.read()</span><br><span class="line"><span class="comment"># 2.打开目标文件准备写入数据</span></span><br><span class="line"><span class="comment"># 拓展：可以指定拷贝后的文件路径</span></span><br><span class="line"><span class="comment"># dst_file = open("C:\\Users\\73654\\Desktop\\dst.txt", "wb")</span></span><br><span class="line">dst_file = open(<span class="string">"C:/Users/73654/Desktop/dst.txt"</span>, <span class="string">"wb"</span>)</span><br><span class="line">dst_file.write(file_data)</span><br><span class="line">src_file.close()</span><br><span class="line">dst_file.close()</span><br><span class="line"><span class="comment"># 实测：500MB的文件照读不误</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>大文件拷贝</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">src_file = open(<span class="string">"big.txt"</span>, <span class="string">"rb"</span>)</span><br><span class="line">dst_file = open(<span class="string">"big_copy.txt"</span>, <span class="string">"wb"</span>)</span><br><span class="line"><span class="comment"># 循环读取文件中的数据</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    file_data = src_file.read(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> file_data:</span><br><span class="line">        <span class="comment"># 表示有数据</span></span><br><span class="line">        dst_file.write(file_data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"数据读取完成:"</span>,file_data) <span class="comment"># b''</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">src_file.close()</span><br><span class="line">dst_file.close()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="文件和文件夹的相关操作"><a href="#文件和文件夹的相关操作" class="headerlink" title="文件和文件夹的相关操作"></a>文件和文件夹的相关操作</h3><p>引入os模块，os有如下函数</p>
<ul>
<li><code>rename(src, dst)</code> 重命名<ul>
<li>文件路径必须存在</li>
</ul>
</li>
<li><p><code>renames(src, dst)</code> 重命名</p>
<ul>
<li>文件路径不存在则创建</li>
</ul>
</li>
<li><p><code>mkdir()</code> 创建文件夹</p>
</li>
<li><code>getcwd()</code> 获取当前目录</li>
<li><code>chdir()</code> 更改当前路径change dir</li>
<li><code>listdir(path)</code> 返回当前文件目录列表</li>
<li><code>remove(file_path)</code> 删除文件</li>
<li><code>rmdir()</code> 删除文件夹，只能删除空的<ul>
<li>若要删非空的，需要引入 文件操作高级模块 shutil</li>
<li><code>shutil.rmtree()</code></li>
</ul>
</li>
<li><code>path.abspath(path)</code> 获取绝对路径</li>
<li><code>path.basename(abs_path)</code> 根据绝对路径获取 文件名</li>
<li><code>path.splitext(abs_path)</code> 根据绝对路径获取 (文件名, 后缀)，可通过拆包获取</li>
</ul>
<blockquote>
<p>划重点：listdir, chdir, rename, rmtree</p>
</blockquote>
]]></content>
      <categories>
        <category>Python学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2013/07/13/hello-world/</url>
    <content><![CDATA[<p>Welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==" title="https://hexo.io/">Hexo<i class="fa fa-external-link"></i></span>! This is your very first post. Check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv" title="https://hexo.io/docs/">documentation<i class="fa fa-external-link"></i></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=" title="https://hexo.io/docs/troubleshooting.html">troubleshooting<i class="fa fa-external-link"></i></span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==" title="https://github.com/hexojs/hexo/issues">GitHub<i class="fa fa-external-link"></i></span>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s" title="https://hexo.io/docs/writing.html">Writing<i class="fa fa-external-link"></i></span></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=" title="https://hexo.io/docs/server.html">Server<i class="fa fa-external-link"></i></span></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s" title="https://hexo.io/docs/generating.html">Generating<i class="fa fa-external-link"></i></span></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZGVwbG95bWVudC5odG1s" title="https://hexo.io/docs/deployment.html">Deployment<i class="fa fa-external-link"></i></span></p>
]]></content>
  </entry>
</search>
